<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Single-cell RNA sequencing ~ Session 3 ¶  ¶ ¶  ¶ </title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <script src="libs/header-attrs-2.25/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Single-cell RNA sequencing ~ Session 3 ¶ <html> ¶ ¶ <hr color='#EB811B' size=1px width=796px> ¶ </html>
]
.author[
### Rockefeller University, Bioinformatics Resource Centre
]
.date[
### <a href="https://rockefelleruniversity.github.io/scRNA-seq/" class="uri">https://rockefelleruniversity.github.io/scRNA-seq/</a>
]

---






## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)

---
# Outlines
- Merge multiple data sets - 4 different approaches for this
- Droplet processing - 3 different approaches for this
- Pseudotime analysis with slingshot
- CITE-seq data processing
- SMART-seq processing

---
class: inverse, center, middle

# Merging Datasets

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Merge multiple datasets
We will discuss a number of approaches and methods we may need to use to merge datasets.

- No corrections
- Reciprocal Principle Component Analysis (RPCA)
- Mutual Nearest Neighbors (MNN)
- Harmony


---
## Example dataset

We will be using the IFNB-Stimulated and Control PBMCs from Seurat Data. The easiest way to get this data is from their custom package *SeuratData* which is hosted on GitHub. 

We will quickly show you how to get this data, but it isn't necessary to run these steps. 


```r
remotes::install_github("satijalab/seurat-data")
```


```r
library(Seurat)
library(SeuratData)
InstallData("ifnb")
LoadData("ifnb")
head(ifnb, 2)
```




```
##                   orig.ident nCount_RNA nFeature_RNA stim seurat_annotations
## AAACATACATTTCC.1 IMMUNE_CTRL       3017          877 CTRL          CD14 Mono
## AAACATACCAGAAA.1 IMMUNE_CTRL       2481          713 CTRL          CD14 Mono
```



---
## Example dataset

This dataset is already loaded in as a Seurat object, and it is already merged. So we need to split it, so we can merge it ourselves! The groups are in the "stim" column of the metadata.


```r
table(ifnb$stim)
ifnb_list &lt;- Seurat::SplitObject(ifnb, split.by = "stim")
ifnb_list
```



At this point you could save your data object for later using the *save()* or *saveRDS()* function.


```r
save("ifnb_list", file = "data/seuOBJ_IFNB_splitByStim.RData")
```

---
## Load in your dataset

We have the ifnb_list saved in an RData object, which you can load in. 


```r
load("data/seuOBJ_IFNB_splitByStim.RData")
```

---
## Create some functions
We are going to try out a few merging approaches. We want to wrap some of our analysis steps into a function to simplify rerunning things.

Normalization: 
  * Log normalization with scale factor = 10,000
  * Find Variable features with vst, select top 2000 variable features
  

```r
data_proc &lt;- function(seu) {
    seu &lt;- NormalizeData(seu, normalization.method = "LogNormalize", scale.factor = 10000)
    seu &lt;- FindVariableFeatures(seu, select.method = "vst", nfeatures = 2000)
    return(seu)
}
```

---
## Create some functions

Make clusters:
  * Scale data with *ScaleData()*
  * Principle Component Analysis by using *RunPCA()* with npcs=30 PCs
  * Make non-linear dimensional reduction in UMAP by using *RunUMAP()* with dims=1:10
  * Estimate Neighbors by using *FindNeighbors()* with dims=1:10
  * Identify clusters with *FindClusters()* by using resolution=0.5
  

```r
quick_clust &lt;- function(seu) {
    set.seed(42)
    seu &lt;- ScaleData(seu, verbose = FALSE)
    seu &lt;- RunPCA(seu, npcs = 30, verbose = FALSE)
    seu &lt;- RunUMAP(seu, reduction = "pca", dims = 1:10, verbose = FALSE)
    seu &lt;- FindNeighbors(seu, reduction = "pca", dims = 1:10, verbose = FALSE)
    seu &lt;- FindClusters(seu, resolution = 0.5, verbose = FALSE)
    return(seu)
}
```

---
class: inverse, center, middle

# Simple Merge

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Concatenate the datasets

We can use *merge()* function to integrate our two data sets, as they are. We need to provide Group information and a name for the project as arguments. 


```r
ifnb_merge &lt;- merge(ifnb_list$CTRL, ifnb_list$STIM, add.cell.ids = c("CTRL", "STIM"),
    project = "ifnb_seuMerge")
head(ifnb_merge, 2)
```

```
##                        orig.ident nCount_RNA nFeature_RNA stim
## CTRL_AAACATACATTTCC.1 IMMUNE_CTRL       3017          877 CTRL
## CTRL_AAACATACCAGAAA.1 IMMUNE_CTRL       2481          713 CTRL
##                       seurat_annotations
## CTRL_AAACATACATTTCC.1          CD14 Mono
## CTRL_AAACATACCAGAAA.1          CD14 Mono
```

---
## Process and make clusters
We can use our processing and clustering functions to analyse our merged dataset. 




```r
ifnb_merge &lt;- data_proc(ifnb_merge)
ifnb_merge &lt;- quick_clust(ifnb_merge)
```

---
## UMAP

Our UMAP shows our cells are distinct, depending on the condition. 


```r
DimPlot(ifnb_merge, group.by = "stim", pt.size = 0.2)
```

![](Session3_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;

---
## Evaluate with cell types
A given cell type should often be clustered together. This pattern indicates the opposite. Different cell types are split into distinct groups depending on the sample.


```r
DimPlot(ifnb_merge, group.by = "seurat_annotations", pt.size = 0.2, split.by = "stim")
```

![](Session3_files/figure-html/sec3_mergeData_woCorr_eval-1.png)&lt;!-- --&gt;

---
## STIM/CTRL don't group

* This result indicates the difference between STIM and CTRL groups is huge.
* Is this a true biological phenomena or is it a batch effect?

---
class: inverse, center, middle

# Merge with reciprocal PCA

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Merge with reciprocal PCA
Reciprocal PCA minimizes the batch effects while merging different data sets.

This workflow is modified from canonical correlation analysis (CCA), which is widely used to merge batches.

---
## RPCA workflow

  1. Normalize data sets. We can use our *data_proc()*. 
  2. Select features for integration by using *SelectIntegrationFeatures()*.
  3. Scale data and process PCA by using the features identified for integration
  4. Identify Anchors for integration by using *FindIntegrationAnchors()*
  5. Integrate data by using *IntegratedData()*
  6. Process *quick_cluster()* and evaluate results with UMAP


---
## Prepare for RPCA merge

First, we prepare the data for integration. We will normalize the data sets separately. Than, we need to identify features for integration. This is similar to the VariableFeatures function we ran on a single dataset. Lastly we run scaling and PCA, using these features.


```r
ifnb_list_rpca &lt;- lapply(ifnb_list, data_proc)

feats &lt;- SelectIntegrationFeatures(ifnb_list_rpca)

ifnb_list &lt;- lapply(ifnb_list, function(seu, feats) {
    seu &lt;- ScaleData(seu, features = feats, verbose = FALSE)
    seu &lt;- RunPCA(seu, features = feats, verbose = FALSE)
    return(seu)
}, feats)
```





---
## Integrating data in RPCA merge

We can then identify anchors. These are the features through which we will integrate our data. Once we have these features, we can then integrate our data sets together.


```r
anchors &lt;- FindIntegrationAnchors(ifnb_list, anchor.features = feats, reduction = "rpca")

ifnb_merge &lt;- IntegrateData(anchorset = anchors)

ifnb_merge
```

```
## An object of class Seurat 
## 16053 features across 13999 samples within 2 assays 
## Active assay: integrated (2000 features, 2000 variable features)
##  1 layer present: data
##  1 other assay present: RNA
```



---
## Evaluating RPCA using clusters

To evaluate how well the merge has worked we must check the clustering. Again we must scale, and then use our *quick_clust* function. 

We can now see that our two data sets overlay with each other.


```r
ifnb_merge &lt;- ScaleData(ifnb_merge)

ifnb_merge &lt;- quick_clust(ifnb_merge)

DimPlot(ifnb_merge, group.by = "stim", pt.size = 0.2)
```

---
## Evaluating RPCA using clusters

We can now see that our two data sets overlay with each other.

![](Session3_files/figure-html/sec3_mergeData_RPCA_cluster2-1.png)&lt;!-- --&gt;

---
## Evaluating RPCA using clusters

We can check the numbers in each cluster. Broadly, there are similar numbers per cluster now. 


```r
tbl &lt;- table(ifnb_merge$stim, ifnb_merge$seurat_clusters)

barplot(tbl, beside = T, main = "Cell numbers in each cluster of each group")
```

![](Session3_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;


---
## Evaluating RPCA using cell types

We can also check the cell types. Using UMAPs we can split and compare across our conditions and cell types. 


```r
DimPlot(ifnb_merge, group.by = "seurat_annotations", split.by = "stim", pt.size = 0.2)
```

![](Session3_files/figure-html/sec3_mergeData_RPCA_eval-1.png)&lt;!-- --&gt;

---
## Evaluating RPCA using cell types

Using heatmaps we can also check how specific each cluster is to each cell type.


```r
library(pheatmap)

tbl &lt;- table(ifnb_merge$seurat_clusters, ifnb_merge$seurat_annotations)
pheatmap(tbl, scale = "column")
```

![](Session3_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---
class: inverse, center, middle

# Merge data with MNN correction

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Merge data with MNN

Mutual Nearest Neighbors (MNN) approach uses paired cells instead of anchor genes to find the difference between batches. 

The MNN correction was published by Marioni et al, Nature (2018). [link](https://www.nature.com/articles/nbt.4091)


---
## Steps for merging data with MNN

1. Convert into SingleCellExperiment
2. Identify features across samples
3. Normalization
4. Identify variables
5. Merge data with MNN correction
6. Build UMAP and clusters
7. Evaluate with UMAP
8. Evaluate composition of samples in each cluster

---
## Preparing to merge data with MNN 

First we have to convert Seurat object to SingleCellExperiment object.


```r
sce_list &lt;- lapply(ifnb_list, function(seu) {
    sce &lt;- as.SingleCellExperiment(seu, assay = "RNA")
    rowData(sce)$SYMBOL &lt;- rownames(sce)
    return(sce)
})


sce_list
```

```
## $CTRL
## class: SingleCellExperiment 
## dim: 14053 6548 
## metadata(0):
## assays(2): counts logcounts
## rownames(14053): AL627309.1 RP11-206L10.2 ... AP001062.7 LRRC3DN
## rowData names(1): SYMBOL
## colnames(6548): AAACATACATTTCC.1 AAACATACCAGAAA.1 ... TTTGCATGCTTCGC.1
##   TTTGCATGGTCCTC.1
## colData names(6): orig.ident nCount_RNA ... seurat_annotations ident
## reducedDimNames(1): PCA
## mainExpName: RNA
## altExpNames(0):
## 
## $STIM
## class: SingleCellExperiment 
## dim: 14053 7451 
## metadata(0):
## assays(2): counts logcounts
## rownames(14053): AL627309.1 RP11-206L10.2 ... AP001062.7 LRRC3DN
## rowData names(1): SYMBOL
## colnames(7451): AAACATACCAAGCT.1 AAACATACCCCTAC.1 ... TTTGCATGCTAAGC.1
##   TTTGCATGGGACGA.1
## colData names(6): orig.ident nCount_RNA ... seurat_annotations ident
## reducedDimNames(1): PCA
## mainExpName: RNA
## altExpNames(0):
```

---
## Preparing to merge data with MNN 

As with RPCA we need to model and identify highly variable genes. For this we will use the scran functions *modelGeneVar()* and *getTopHVGs()*. We simply provide our SingleCellExperiment object.


```r
library(scran)
dec_list &lt;- lapply(sce_list, modelGeneVar)

hvgc_list &lt;- lapply(sce_list, getTopHVGs, prop = 0.1)
```

---
## Preparing to merge data with MNN 

Next we will find the features that are shared between samples. We must first define the shared "universe" of genes between our samples, and subset our variable genes to these. We can then combine the the variance to find variable features in both data sets. 


```r
universe &lt;- intersect(rownames(sce_list$CTRL), rownames(sce_list$STIM))
sce_list &lt;- lapply(sce_list, function(sce, universe) {
    sce &lt;- sce[universe, ]
    return(sce)
}, universe)
dec_list &lt;- lapply(dec_list, function(dec, universe) {
    dec &lt;- dec[universe, ]
    return(dec)
}, universe)

combined_dec &lt;- combineVar(dec_list$CTRL, dec_list$STIM)
chosen_hvgs &lt;- combined_dec$bio &gt; 0
```

---
## Merge data with MNN
We will use the batchelor package to run MNN with the *fastMNN()* function. 
  * d: number of principles evaluated
  * k: number of nearest neighbors to consider
  * subset.row: subset genes. Here, we are using the top variable features

  

```r
library(batchelor)
mnn_res &lt;- fastMNN(CTRL = sce_list$CTRL, STIM = sce_list$STIM, d = 50, k = 20, subset.row = chosen_hvgs)
mnn_res
```

```
## class: SingleCellExperiment 
## dim: 1958 13999 
## metadata(2): merge.info pca.info
## assays(1): reconstructed
## rownames(1958): HES4 ISG15 ... CTD-2521M24.5 AJ006998.2
## rowData names(1): rotation
## colnames(13999): AAACATACATTTCC.1 AAACATACCAGAAA.1 ... TTTGCATGCTAAGC.1
##   TTTGCATGGGACGA.1
## colData names(1): batch
## reducedDimNames(1): corrected
## mainExpName: NULL
## altExpNames(0):
```

---
## Merge data with MNN

The resulting SingleCellExperiment object contains the batch information. We can also retrieve a matrix of our dimension reduction results and corrected log counts with the *reducedDim()* and *assay()* functions. 


```r
table(mnn_res$batch)
```

```
## 
## CTRL STIM 
## 6548 7451
```


```r
reducedDim(mnn_res, "corrected")[1:2, ]
```

```
##                       [,1]         [,2]        [,3]        [,4]        [,5]
## AAACATACATTTCC.1 0.4692084  0.002558369  0.24112460 -0.01932947 -0.02919753
## AAACATACCAGAAA.1 0.4849751 -0.221433871 -0.03194567 -0.04457301  0.02085704
##                           [,6]        [,7]       [,8]         [,9]       [,10]
## AAACATACATTTCC.1 -0.0001116517 -0.05219879 0.01560541  0.018456590 -0.02042355
## AAACATACCAGAAA.1  0.0208653688  0.02518230 0.05640069 -0.001590786  0.02042924
##                        [,11]       [,12]        [,13]       [,14]         [,15]
## AAACATACATTTCC.1 0.008021788  0.04396844  0.005131837  0.01141104 -0.0002610285
## AAACATACCAGAAA.1 0.006484710 -0.02690261 -0.014495237 -0.01603656  0.0417677341
##                         [,16]       [,17]        [,18]        [,19]       [,20]
## AAACATACATTTCC.1  0.001044311  0.02583133 -0.004660621  0.003453847 0.007833429
## AAACATACCAGAAA.1 -0.002738321 -0.01539083  0.028006124 -0.010241152 0.016709705
##                         [,21]       [,22]       [,23]        [,24]       [,25]
## AAACATACATTTCC.1  0.004925765  0.01688819  0.01693241  0.003615093 0.007882780
## AAACATACCAGAAA.1 -0.019963264 -0.02561860 -0.01056931 -0.010869554 0.005000097
##                        [,26]        [,27]        [,28]        [,29]
## AAACATACATTTCC.1 -0.01073247 0.0075159768  0.006422343 -0.004441872
## AAACATACCAGAAA.1  0.02215599 0.0008773935 -0.003697461 -0.014406621
##                         [,30]       [,31]        [,32]        [,33]
## AAACATACATTTCC.1  0.002957031  0.01006521 -0.002491118 -0.001875366
## AAACATACCAGAAA.1 -0.003685269 -0.01067559 -0.021875400  0.011806193
##                         [,34]        [,35]        [,36]        [,37]
## AAACATACATTTCC.1 -0.008862147  0.002032289 -0.008468607 -0.007954116
## AAACATACCAGAAA.1  0.003560579 -0.002324063  0.002952769 -0.006034000
##                          [,38]        [,39]       [,40]        [,41]
## AAACATACATTTCC.1 -0.0009951656  0.002792573 0.002435519 -0.015530207
## AAACATACCAGAAA.1 -0.0009532853 -0.002280508 0.010147310  0.003641573
##                          [,42]         [,43]        [,44]       [,45]
## AAACATACATTTCC.1  0.0009633955  0.0026935385 0.0002299275 0.003499859
## AAACATACCAGAAA.1 -0.0034695643 -0.0008694543 0.0037271426 0.002181876
##                         [,46]        [,47]        [,48]        [,49]
## AAACATACATTTCC.1 -0.001978661 -0.009881723 -0.004609779  0.001163945
## AAACATACCAGAAA.1 -0.001995334 -0.005362670  0.001793127 -0.005419268
##                          [,50]
## AAACATACATTTCC.1 -0.0095770715
## AAACATACCAGAAA.1  0.0003581869
```


```r
assay(mnn_res, "reconstructed")[1:2, 1:5]
```

```
## &lt;2 x 5&gt; LowRankMatrix object of type "double":
##       AAACATACATTTCC.1 AAACATACCAGAAA.1 AAACATACCTCGCT.1 AAACATACCTGGTA.1
## HES4      -0.001084748     -0.001208982     -0.001217450      0.001368426
## ISG15     -0.112621047     -0.128283733     -0.111386938     -0.138798378
##       AAACATACGATGAA.1
## HES4      -0.001118786
## ISG15     -0.129904496
```

---
## UMAP of data merged with MNN 

Make UMAP using the scater package.


```r
library(scater)
set.seed(1001)
mnn_res &lt;- runUMAP(mnn_res, dimred = "corrected")
mnn_res$batch &lt;- factor(mnn_res$batch)
plotUMAP(mnn_res, colour_by = "batch")
```

![](Session3_files/figure-html/sec3_dataMerge_MNN_cluster-1.png)&lt;!-- --&gt;


---
## Clustering data merged with MNN 

We will cluster using SNN graph approach from scran as this is comptaible with our SingleCellExperiment object. 


```r
snn.gr &lt;- buildSNNGraph(mnn_res, use.dimred = "corrected")
cluster_mnn &lt;- igraph::cluster_louvain(snn.gr)$membership
table(cluster_mnn)
```

```
## cluster_mnn
##    1    2    3    4    5    6    7    8    9   10   11   12   13 
##  806  839 1534  418 1072  835  933  848  924 1931 1350 2453   56
```

---
## Clustering data merged with MNN 

Lets check the UMAP for our clustered results.


```r
mnn_res$cluster &lt;- factor(cluster_mnn)
plotUMAP(mnn_res, colour_by = "cluster")
```

![](Session3_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;

---
## Clustering data merged with MNN 

We can also check how many cells from each cluster belong to each group. With this approach you can see that there is a lot more group-specific clusters.


```r
tbl &lt;- table(mnn_res$batch, mnn_res$cluster)
barplot(tbl, beside = T, main = "Cell numbers in each cluster of each group")
```

![](Session3_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;

---
## Evaluate with cell types

We must annotate our SingleCellExperiment object with different cell type information. We can then visualize the cell types on our UMAP. 


```r
cellType &lt;- lapply(sce_list, function(x) {
    res &lt;- setNames(as.character(colData(x)$seurat_annotations), colnames(x))
    return(res)
})
cell_type &lt;- c(cellType$CTRL, cellType$STIM)
mnn_res$cell_type &lt;- cell_type[match(rownames(colData(mnn_res)), names(cell_type))]
mnn_res$cell_type &lt;- factor(mnn_res$cell_type)
```


---
## Evaluate with cell types


```r
plotUMAP(mnn_res, colour_by = "cell_type")
```

![](Session3_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;

---
## Evaluate with cell types

We can also  use a heatmap to look at the specificity of each cell type to each cluster. Most are cluster-specific.


```r
tbl &lt;- table(mnn_res$cluster, mnn_res$cell_type)
pheatmap(tbl, scale = "column")
```

![](Session3_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;

---
## MNN vs RPCA

Performance is dependent on experimental context. 

Generally:
* RPCA - More homogeneous   
* MNN - More heterogeneous

---
class: inverse, center, middle

# Merge data with Harmony

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Harmony
- Harmony is an R package for single-cell data integration [liike](https://www.nature.com/articles/s41592-019-0619-0).
- The user manual of Harmony is also available [link](https://portals.broadinstitute.org/harmony/articles/quickstart.html).
- There is also a python implementation of this package. 
- Here, we will demonstrate how to integrate harmony into Seurat regular workflow.

---
## Prepare data for Harmony
We can prepare for Harmony in much the same way as we prepare for the simple Seurat merge: merge, normalize, scale, PCA and UMAP.


```r
seu_obj &lt;- merge(ifnb_list$CTRL, ifnb_list$STIM)
seu_obj &lt;- data_proc(seu_obj)
seu_obj &lt;- ScaleData(seu_obj)
seu_obj &lt;- RunPCA(seu_obj)
seu_obj &lt;- RunUMAP(seu_obj, reduction = "pca", dims = 1:10, reduction.name = "umap")
```

---
## Prepare data for Harmony

As you can see we are back with our completely seperate groups. 


```r
DimPlot(seu_obj)
```

![](Session3_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;

---
## Merge data with Harmony

We can use the *RunHarmony()* function to implement the Harmony correction. 


```r
library(harmony)
seu_obj &lt;- RunHarmony(seu_obj, group.by.vars = "stim", assay.use = "RNA")
seu_obj &lt;- RunUMAP(seu_obj, reduction = "harmony", dims = 1:10, reduction.name = "umap_harmony")
DimPlot(seu_obj, reduction = "umap_harmony")
```



---
## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)


---
class: inverse, center, middle

# Cell type annotation

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Cell type annotation
To annotate the Single-cell data sets, we can evaluate the gene expression pattern of well known cell-type specific marker genes and make a manual annotation, like we did in section II. Here, we will introduce two more strategies to make cell type annotations automatically:
  1. Mapping and annotating query datasets with Seurat using a reference data set.  [link](https://satijalab.org/seurat/articles/integration_mapping.html)
  2. Make annotation with SingleR [link](https://bioconductor.org/packages/release/bioc/html/SingleR.html)

---
## Prepare example datasets

The demo data, *panc8*,  was fetched by using SeuratData(). It contains single-cell RNA-Seq of human pancreatic islet sequenced with different techniques.

The demo data contains
  * CELSeq dataset1 (*GSE81076*), as reference
  * CELSeq dataset2 (*GSE85241*), as reference
  * SMART-Seq2 (*E-MTAB-5061*), as reference
  * Fluidigm C1 (*GSE86469*), as query
  
As we did before we will split this dataset. We have also prepped this dataset for you, if you want to load the data object in directly.
  

```r
library(Seurat)
library(SeuratData)
InstallData("panc8")
data("panc8")
```



---
## Prepare example datasets

Split up the datasets by techniques using *SplitObject()*.


```r
panc8 &lt;- UpdateSeuratObject(panc8)
seu_list &lt;- SplitObject(panc8, split.by = "tech")
names(seu_list) &lt;- c("celseq1", "celseq2", "smartseq", "fluidigmc1", "indrop")
```




```r
load("data/panc8.RData")
```

---
## Prepare reference dataset
For this we need a reference dataset and a query dataset. Merge celseq1 and celseq2 data with RPCA to make the reference.


```r
seu_list &lt;- lapply(seu_list, data_proc)
ref_list &lt;- seu_list[c("celseq1", "celseq2")]
feats &lt;- SelectIntegrationFeatures(ref_list)
ref_list &lt;- lapply(ref_list, function(seu, feats) {
    seu &lt;- ScaleData(seu, features = feats, verbose = FALSE)
    seu &lt;- RunPCA(seu, features = feats, verbose = FALSE)
    return(seu)
}, feats)
```

---
## Prepare reference dataset
Merge celseq1 and celseq2 data with RPCA


```r
anchors &lt;- FindIntegrationAnchors(ref_list, anchor.features = feats, reduction = "rpca")
ref_panc &lt;- IntegrateData(anchorset = anchors)
ref_panc &lt;- ScaleData(ref_panc)
ref_panc &lt;- quick_clust(ref_panc)
```

---
## Prepare reference dataset

How does the data look?


```r
DimPlot(ref_panc, group.by = "seurat_clusters", split.by = "tech", pt.size = 0.2,
    label = TRUE)
```

![](Session3_files/figure-html/unnamed-chunk-37-1.png)&lt;!-- --&gt;


---
## Reference and query datasets


```r
panc_list &lt;- list(ref = ref_panc, query = seu_list$smartseq)
feats &lt;- SelectIntegrationFeatures(panc_list)
panc_list &lt;- lapply(panc_list, function(seu, feats) {
    seu &lt;- ScaleData(seu, features = feats, verbose = FALSE)
    seu &lt;- RunPCA(seu, features = feats, verbose = FALSE)
    return(seu)
}, feats)
```

---
## Predict cell types for query

Identify the anchors between reference and query data sets, using *FindTransferAnchors()*. These are essential to transfer information from our reference to our query. We can then transfer the cell type information. For each cell in query dataset, the score for each given cell type was estimated by the gene expression pattern of anchor genes using the *TransferData()* function. 


```r
anchors &lt;- FindTransferAnchors(reference = panc_list$ref, query = panc_list$query,
    dims = 1:30, reference.reduction = "pca")
pred_res &lt;- TransferData(anchorset = anchors, refdata = panc_list$ref$celltype)
head(pred_res, 2)
```

```
##       predicted.id prediction.score.gamma prediction.score.acinar
## AZ_A2        gamma              0.9913817                       0
## AZ_B9        alpha              0.0000000                       0
##       prediction.score.alpha prediction.score.delta prediction.score.beta
## AZ_A2            0.008618342                      0                     0
## AZ_B9            1.000000000                      0                     0
##       prediction.score.ductal prediction.score.endothelial
## AZ_A2                       0                            0
## AZ_B9                       0                            0
##       prediction.score.activated_stellate prediction.score.schwann
## AZ_A2                                   0                        0
## AZ_B9                                   0                        0
##       prediction.score.mast prediction.score.macrophage
## AZ_A2                     0                           0
## AZ_B9                     0                           0
##       prediction.score.epsilon prediction.score.quiescent_stellate
## AZ_A2                        0                                   0
## AZ_B9                        0                                   0
##       prediction.score.max
## AZ_A2            0.9913817
## AZ_B9            1.0000000
```

---
## Predict cell types for query
The cell type with highest score was assigned to the given cell. We can visualize this score with a heatmap. 


```r
mat &lt;- as.matrix(pred_res[, -c(1, 15)])
colnames(mat) &lt;- gsub("prediction.score.", "", colnames(mat))
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE)
```

![](Session3_files/figure-html/unnamed-chunk-38-1.png)&lt;!-- --&gt;

---
## Load cell types into query


```r
pred_cellType &lt;- setNames(pred_res$predicted.id, rownames(pred_res))
panc_list$query[["cellType_predBySeurat"]] &lt;- pred_cellType[match(Cells(panc_list$query),
    names(pred_cellType))]

head(panc_list$query, 2)
```

```
##       orig.ident nCount_RNA nFeature_RNA      tech replicate assigned_cluster
## AZ_A2         AZ     384801         3611 smartseq2 smartseq2             &lt;NA&gt;
## AZ_B9         AZ     654549         4433 smartseq2 smartseq2             &lt;NA&gt;
##       celltype   dataset cellType_predBySeurat
## AZ_A2    gamma smartseq2                 gamma
## AZ_B9    alpha smartseq2                 alpha
```

```r
table(panc_list$query$cellType_predBySeurat)
```

```
## 
##             acinar activated_stellate              alpha               beta 
##                192                 55               1028                316 
##              delta             ductal        endothelial              gamma 
##                122                439                 21                200 
##         macrophage               mast quiescent_stellate            schwann 
##                  7                  7                  5                  2
```

---
## Annotation with SingleR
[SingleR](https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html) is bioconductor package which can be used to predict annotations of a single-cell dataset.

This package uses SingleCellExperiment objects, so we need to convert our Seurat object.


```r
sce_list &lt;- lapply(panc_list, function(seu) {
    sce &lt;- as.SingleCellExperiment(seu, assay = "RNA")
    return(sce)
})
```

---
## Annotation with SingleR

The score is generated comparing the expression levels of a cell in query dataset and the expression pattern of certain group (eg. cell types) in reference dataset. A cell would be assigned as the cell type which has highest score.


```r
library(SingleR)
pred_res &lt;- SingleR(ref = sce_list$ref, test = sce_list$query, labels = sce_list$ref$celltype)
head(pred_res, 2)
```

```
## DataFrame with 2 rows and 4 columns
##                               scores      labels delta.next pruned.labels
##                             &lt;matrix&gt; &lt;character&gt;  &lt;numeric&gt;   &lt;character&gt;
## AZ_A2 0.300904:0.178568:0.436055:...       gamma  0.1394303            NA
## AZ_B9 0.318227:0.227997:0.529730:...       alpha  0.0861217         alpha
```

---
## Annotation with SingleR
By converting to a matrix, we can check the cell type scoring using a heatmap. 


```r
mat &lt;- as.matrix(pred_res$scores)
rownames(mat) &lt;- rownames(pred_res)
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE)
```

![](Session3_files/figure-html/unnamed-chunk-40-1.png)&lt;!-- --&gt;


---
## Import SingleR annotation

Lastly we want to add our annotation back to our query dataset. 


```r
cell_type &lt;- setNames(pred_res$pruned.labels, rownames(pred_res))
panc_list$query$cellType_predBySingleR &lt;- cell_type[match(Cells(panc_list$query),
    names(cell_type))]
head(panc_list$query, 2)
```

```
##       orig.ident nCount_RNA nFeature_RNA      tech replicate assigned_cluster
## AZ_A2         AZ     384801         3611 smartseq2 smartseq2             &lt;NA&gt;
## AZ_B9         AZ     654549         4433 smartseq2 smartseq2             &lt;NA&gt;
##       celltype   dataset cellType_predBySeurat cellType_predBySingleR
## AZ_A2    gamma smartseq2                 gamma                   &lt;NA&gt;
## AZ_B9    alpha smartseq2                 alpha                  alpha
```


---
## Seurat vs SingleR annotation

First we can compare this back to the original annotation. We will look for how many overlap.

Seurat annotation:

```r
table(panc_list$query$cellType_predBySeurat == panc_list$query$celltype)
```

```
## 
## FALSE  TRUE 
##    41  2353
```

SingleR annotation:

```r
table(panc_list$query$cellType_predBySingleR == panc_list$query$celltype)
```

```
## 
## FALSE  TRUE 
##    35  2299
```


---
## Seurat vs SingleR annotation

Next we can compare our two annotations:


```r
table(panc_list$query$cellType_predBySeurat == panc_list$query$cellType_predBySingleR)
```

```
## 
## FALSE  TRUE 
##    37  2297
```

```r
tbl &lt;- table(panc_list$query$cellType_predBySeurat, panc_list$query$cellType_predBySingleR)
pheatmap::pheatmap(tbl, scale = "row")
```

![](Session3_files/figure-html/unnamed-chunk-43-1.png)&lt;!-- --&gt;

---
## Seurat vs SingleR annotation

This isn't always the case. This is good demonstration data. 

* Seurat: Wins on speed
* SingleR: More reliable and consistent



---
## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)

---
class: inverse, center, middle

# Droplet processing

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Droplet processing

Often empty droplets can still make their way past Cell Ranger, or we may want to do custom filtering outside of Cell Ranger.

Ambient RNAs from lysed cells can contaminate droplets and make empty droplets seem like they contain a cell. 

We are revisiting the PBMC 10k data from 10X Genomics as an example to deal with these issues. This time we will use the raw matrix.


---
## Detect TRUE cells
- The knee plot is available in the Web Summary from cellranger.
- We can also draw the knee plot by using DropletUtils


---
## Grab dataset


```r
download.file("https://cf.10xgenomics.com/samples/cell-exp/6.1.0/10k_PBMC_3p_nextgem_Chromium_Controller/10k_PBMC_3p_nextgem_Chromium_Controller_raw_feature_bc_matrix.tar.gz",
    "10k_PBMC_3p_nextgem_Chromium_Controller_raw_feature_bc_matrix.tar.gz")
```


```r
untar("10k_PBMC_3p_nextgem_Chromium_Controller_raw_feature_bc_matrix.tar.gz")
```

---
## Load dataset

We need to load in the dataset, but it is important not to set any filters yet. 


```r
library(DropletUtils)
library(Seurat)

raw_mtx &lt;- Seurat::Read10X("raw_feature_bc_matrix")
dim(raw_mtx)
```

```
## [1]   36601 2099284
```


---
## Load dataset

Calculate the counts for each cell barcode and their rank.


```r
bcrank &lt;- barcodeRanks(raw_mtx)
head(bcrank, 2)
```

```
## DataFrame with 2 rows and 3 columns
##                         rank     total    fitted
##                    &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt;
## AAACCCAAGAAACCAT-1   1752547         0        NA
## AAACCCAAGAAACCCA-1    914872         1        NA
```

---
## Draw Knee plot

To draw a custom knee plot we need to remove duplicated ranks and grab the knee and inflection points. 


```r
uniq &lt;- !duplicated(bcrank$rank)
bcrank &lt;- bcrank[uniq, ]

knee &lt;- metadata(bcrank)$knee
message(paste0("knee point: ", knee))
inflection &lt;- metadata(bcrank)$inflection
message(paste0("inflection point: ", inflection))
```

---
## Draw Knee plot

We can now draw our knee plot using *ggplot()*. 


```r
ggplot(as.data.frame(bcrank), aes(x = rank, y = total)) + geom_point() + geom_hline(yintercept = knee,
    linetype = "dashed", color = "blue") + geom_hline(yintercept = inflection, linetype = "dashed",
    color = "green") + scale_x_continuous(trans = "log10") + scale_y_continuous(trans = "log10") +
    labs(x = "cell barcode ranked by counts", y = "UMI counts of each cell barcode") +
    theme_classic()
```

---
## Draw Knee plot

We can now draw our knee plot using *ggplot()*. The knee is labelled in blue. The inflection is labelled in green.

![](Session3_files/figure-html/unnamed-chunk-50-1.png)&lt;!-- --&gt;


---
## Detect empty droplets

We can detect empty droplets with *DropletUtils::emptyDrops()*.
- The p-value for each cell is performed by Monte Carlo simulation basing on the deviation of a given cell to the ambient RNA pool.



```r
e.out &lt;- emptyDrops(raw_mtx)
e.out &lt;- e.out[order(e.out$FDR), ]
head(e.out)
```

```
## DataFrame with 6 rows and 5 columns
##                        Total   LogProb    PValue   Limited       FDR
##                    &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;logical&gt; &lt;numeric&gt;
## AAACCCAAGGTAGTCG-1      6088  -7854.52 9.999e-05      TRUE         0
## AAACCCACAATCCAGT-1     14628 -17829.20 9.999e-05      TRUE         0
## AAACCCACACCGTCTT-1      7642  -9887.60 9.999e-05      TRUE         0
## AAACCCACATCTCATT-1      9834 -13742.83 9.999e-05      TRUE         0
## AAACCCACATTGACTG-1      7409 -10416.66 9.999e-05      TRUE         0
## AAACCCAGTCACTGAT-1      5834  -8026.81 9.999e-05      TRUE         0
```

---
## Detect empty droplets 

The distribution of UMI counts per cell is often a bimodal distribution. The high-UMI group are likely droplets with a cell. In contrast, the droplets with low UMI are more likely empty droplets containing ambient RNAs.


```r
ggplot(as.data.frame(e.out), aes(x = Total)) + geom_histogram() + geom_vline(xintercept = knee,
    color = "red", linetype = "dashed") + labs(x = "UMI counts per cell", y = "Frequency") +
    scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + theme_classic()
```

---
## Detect empty droplets 

The distribution of UMI counts per cell is often a bimodal distribution. The high-UMI group are likely droplets with a cell. In contrast, the droplets with low UMI are more likely empty droplets containing ambient RNAs.

![](Session3_files/figure-html/unnamed-chunk-52-1.png)&lt;!-- --&gt;

---
## Filter empty droplets

In the DropletUtils manual, the FDR threshold is set to 0.001 
in most cases. We can filter based on this cutoff. 


```r
table(e.out$FDR &lt; 0.001)
```

```
## 
## FALSE  TRUE 
##   610 11575
```

```r
cell_sel &lt;- rownames(e.out)[e.out$FDR &lt; 0.001]
filt_mtx &lt;- raw_mtx[, colnames(raw_mtx) %in% cell_sel]
```


---
## Ambient RNAs

* The cell-free RNA molecules randomly spread in the solution. It can be enclosed into droplets during the steps of library preparation. So, it would be falsely increase the UMI counts of genes.

* Ambient RNAs present two signature
  + The majority are found in the empty droplets population.
  + No specificity. This contamination can make a single cell look like it expresses two (or more) mutually exclusive marker genes.
  
* According to these two properties, we could estimate ambient RNA contamination rates and correct it. Here we will demonstrate how to correct ambient RNA contamination with DropletUtils and SoupX, respectively.


---
## Correct ambient RNAs

Lets start by estimating our ambient RNA contamination. This is from DropletUtils.


```r
amb &lt;- metadata(e.out)$ambient[, 1]
head(amb)
```

```
##   AL627309.1   AL627309.3   AL627309.5   AL627309.4   AL669831.2    LINC01409 
## 8.369426e-07 9.859354e-08 5.635719e-06 9.859354e-08 9.859354e-08 6.511074e-06
```

---
## Correct ambient RNAs

We can read back in our filtered PBMC data.




```r
download.file("https://cf.10xgenomics.com/samples/cell-exp/6.1.0/10k_PBMC_3p_nextgem_Chromium_Controller/10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz",
    "10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz")
untar("10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz")
filt_mtx &lt;- Seurat::Read10X("filtered_feature_bc_matrix/")
```



---
## Correct ambient RNAs

Then filter out empty droplets.


```r
filt_mtx_drop &lt;- filt_mtx[rownames(filt_mtx) %in% names(amb), ]
seu &lt;- CreateSeuratObject(filt_mtx_drop)
```




```r
seu &lt;- data_proc(seu)
seu &lt;- ScaleData(seu)
seu &lt;- quick_clust(seu)
sce &lt;- as.SingleCellExperiment(seu, assay = "RNA")
```

---
## Correct ambient RNAs


```r
plotUMAP(sce, colour_by = "seurat_clusters")
```

![](Session3_files/figure-html/unnamed-chunk-60-1.png)&lt;!-- --&gt;

---
## Correct ambient RNAs
Lets put our uncorrected, filtered dataset in a list. 


```r
seu_list &lt;- list()
seu_list[["woCorr"]] &lt;- seu
```

---
## Correct ambient RNAs

We can use the to *removeAmbience()* function to remove ambient RNAs. 


```r
out &lt;- removeAmbience(counts(sce), ambient = amb, groups = sce$seurat_clusters)
rownames(out) &lt;- rownames(sce)
colnames(out) &lt;- colnames(sce)
```

---
## Correct ambient RNAs

Now that we have run a correction, we want to reprocess and cluster our data.


```r
seu_list[["withCorr"]] &lt;- CreateSeuratObject(out)
seu_list[["withCorr"]] &lt;- data_proc(seu_list[["withCorr"]])
seu_list[["withCorr"]] &lt;- ScaleData(seu_list[["withCorr"]])
seu_list[["withCorr"]] &lt;- quick_clust(seu_list[["withCorr"]])
```

---
## Evaluate with marker genes

Lets compare to our marker genes. 


```r
mark_gene &lt;- c("CCR7", "CD8A", "MS4A1", "CD14", "FCGR3A", "FCER1A", "GNLY", "NKG7",
    "PPBP")
mark_gene
```

```
## [1] "CCR7"   "CD8A"   "MS4A1"  "CD14"   "FCGR3A" "FCER1A" "GNLY"   "NKG7"  
## [9] "PPBP"
```

---
## Evaluate with marker genes

First lets look at the UMAP without ambient RNA correction. 


```r
DimPlot(seu_list$woCorr, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) +
    NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-63-1.png)&lt;!-- --&gt;

---
## Evaluate with marker genes

Lets now compare to UMAP wit ambient RNA correction.


```r
DimPlot(seu_list$withCorr, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) +
    NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-64-1.png)&lt;!-- --&gt;

---
## Evaluate with marker genes

Lets now look at a violin plot in the uncorrected data.


```r
VlnPlot(seu_list$woCorr, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-65-1.png)&lt;!-- --&gt;

---
## Evaluate with marker genes

And then again in the corrected.


```r
VlnPlot(seu_list$withCorr, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-66-1.png)&lt;!-- --&gt;



---
## Ambient RNA and SoupX

SoupX is an alternative tool for droplet processing, developed for ambient RNA detection and correction [link](https://github.com/constantAmateur/SoupX). It includes the following steps
- Estimate ambient RNA expression in the empty droplets.
- Estimate contamination rate by using the ambient RNA expression levels across clusters.
- Correct ambient RNA contamination.

---
## Prepare essential files

We need our filtered and unfiltered matrix. Plus our processed filtered Seurat object.


```r
clust &lt;- setNames(seu$seurat_clusters, Cells(seu))
seu_filt &lt;- seu
```

---
## Import Matrices
Import our matrices into the SoupX channel object.


```r
library(SoupX)
soupOBJ &lt;- SoupChannel(raw_mtx, filt_mtx)
soupOBJ &lt;- setClusters(soupOBJ, clust)
```


---
## Automatic estimates

The *autoEstCont()* can be used to detect contamination. We can then export the correct counts with *adjustCount()*.


```r
soupOBJ &lt;- autoEstCont(soupOBJ)

autoCor_mtx &lt;- adjustCounts(soupOBJ)
```







---
## Build a Seurat object

We will now put our corrected matrix into a Seurat object.


```r
seu &lt;- CreateSeuratObject(autoCor_mtx)
seu &lt;- data_proc(seu)
seu &lt;- ScaleData(seu)
seu &lt;- quick_clust(seu)
seu_autoCorr &lt;- seu
```




---
## Estimate contamination

We can estimate contamination using known marker genes.

```r
mark_list &lt;- list(`CD4 T-cell` = c("IL7R", "CCR7", "S100A4"), `CD8 T-cell` = c("CD8A"),
    `B-Cell` = c("MS4A1"), Monocyte = c("CD14", "FCGR3A"), DC = c("FCER1A"), NK = c("NKG7",
        "GNLY"), Platelet = c("PPBP"))

use_toEst &lt;- estimateNonExpressingCells(soupOBJ, nonExpressedGeneList = mark_list)
soupOBJ &lt;- calculateContaminationFraction(soupOBJ, mark_list, useToEst = use_toEst)
rho &lt;- unique(soupOBJ$metaData$rho)
rho
```

```
## [1] 0.0193281
```



---
## Export matrix after correction


```r
soupOBJ &lt;- setContaminationFraction(soupOBJ, rho, forceAccept = TRUE)
estCor_mtx &lt;- adjustCounts(soupOBJ)
```







---
## Add exported matrix to Seurat


```r
seu &lt;- CreateSeuratObject(estCor_mtx)
seu &lt;- data_proc(seu)
seu &lt;- ScaleData(seu)
seu &lt;- quick_clust(seu)
seu_estCorr &lt;- seu
```

---
## Evaluate marker genes


```r
mark_gene &lt;- c("CCR7", "CD8A", "MS4A1", "CD14", "FCGR3A", "FCER1A", "GNLY", "NKG7",
    "PPBP")
mark_gene
```

```
## [1] "CCR7"   "CD8A"   "MS4A1"  "CD14"   "FCGR3A" "FCER1A" "GNLY"   "NKG7"  
## [9] "PPBP"
```

---
## Without Correction


```r
DimPlot(seu_filt, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) + NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-80-1.png)&lt;!-- --&gt;

---
## Without Correction


```r
VlnPlot(seu_filt, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-81-1.png)&lt;!-- --&gt;

---
## With Correction (auto)


```r
DimPlot(seu_autoCorr, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) +
    NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-82-1.png)&lt;!-- --&gt;

---
## With Correction (auto)


```r
VlnPlot(seu_autoCorr, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-83-1.png)&lt;!-- --&gt;

---
## With Correction (est)


```r
DimPlot(seu_estCorr, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) +
    NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-84-1.png)&lt;!-- --&gt;

---
## With Correction (est)


```r
VlnPlot(seu_estCorr, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-85-1.png)&lt;!-- --&gt;



---
## CellBender

CellBender is a python toolkit developed to eliminate technical artifacts from scRNA-Seq data such as empty droplets and ambient RNAs [link](https://cellbender.readthedocs.io/en/latest/introduction/index.html). It is run from within python. 

In the current version, it contains remove-background module, which is applied to:
  * Detect empty droplets and ambient RNAs from raw count matrix in CellRanger output
  * To remove empty droplets and to correct the interference of ambient RNAs
  
* CellBender is based on machine-learning strategy. It's quite time-consuming. We can speed up the processing by using CUDA version of CellBender. However, this means you will need access to a GPU. 
---
## CellBender in python


```bash
input_h5=the_raw_matrix_in_h5_format_from_cellranger #essential
output_h5=assign_the_h5_file_path_for_the_cellbender_corrected_matrix # essential
expect_cell=expected_cell_number_can_be_find_in_cellranger_Web_Summary # essential
droplet_num=the_total_number_of_droplets_assigned_while_sequencing # default 25,000
fpr=threshols_of_FALSE_POSITIVE_RATE # default 0.01
epochs=number_of_epochs_to_train # default 150
num_train=number_of_times_to_attempt_to_train_the_model # default 1. would speed up while setting greater
#
cellbender remove-background --input $input_h5 --output $output_h5 --expected-cells $expect_cell --total-droplets-included $droplet_num --fpr $fpr --epochs $epochs --num-training-tries $num_train --cuda False
```

---
## Cell Ranger vs. CellBender

We have some processed results here from CellBender. We can compare this to our filtered matrix from Cell Ranger.


```r
cbFilt_mtx &lt;- Read10X_h5("data/cbFilt_PBMCv3_20230324_filtered.h5")
dim(cbFilt_mtx)
```

```
## [1] 36601 12244
```

```r
dim(filt_mtx)
```

```
## [1] 36601 11485
```

---
## Data processing


```r
message("processing matrix from CellRanger")
seu &lt;- CreateSeuratObject(filt_mtx)
seu &lt;- data_proc(seu)
seu &lt;- ScaleData(seu)
seu &lt;- quick_clust(seu)
seu_filt &lt;- seu

message("processing matrix from CellBender")
seu &lt;- CreateSeuratObject(cbFilt_mtx)
seu &lt;- data_proc(seu)
seu &lt;- ScaleData(seu)
seu &lt;- quick_clust(seu)
seu_cbFilt &lt;- seu
```



---
## Evaluate with marker gene exprssion

```r
mark_gene &lt;- c("CD3E", "CCR7", "CD8A", "MS4A1", "CD14", "FCGR3A", "FCER1A", "GNLY",
    "PPBP")
mark_gene
```

```
## [1] "CD3E"   "CCR7"   "CD8A"   "MS4A1"  "CD14"   "FCGR3A" "FCER1A" "GNLY"  
## [9] "PPBP"
```


---
## Evaluate with marker gene exprssion


```r
DimPlot(seu_filt, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) + NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-88-1.png)&lt;!-- --&gt;

---
## Evaluate with marker gene exprssion


```r
DimPlot(seu_cbFilt, group.by = "seurat_clusters", pt.size = 0.1, label = TRUE) +
    NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-89-1.png)&lt;!-- --&gt;

---
## Evaluate with marker gene exprssion


```r
VlnPlot(seu_filt, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-90-1.png)&lt;!-- --&gt;


---
## Evaluate with marker gene exprssion


```r
VlnPlot(seu_cbFilt, features = mark_gene, group.by = "seurat_clusters", pt.size = 0)
```

![](Session3_files/figure-html/unnamed-chunk-91-1.png)&lt;!-- --&gt;



---
## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)

---
class: inverse, center, middle

# Trajectory and Psuedotime analysis

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Trajectory and pseudotime analysis
- Many biological processes are link a dynamic changes in the cellular state e.g. immune cell activation.
- Trajectory analysis is a way to postulate this kind dynamic changes in single-cell data.
- According to the postulated trajectories, we can also estimate pseudotime of each cell included in a particular trajectory. 
- Here, we demonstrate how to find out trajectories reflecting hematopoietic stem cell differentiation.

---
## Prepare the demo
- In this practice, we are using the SMART-Seq data of mouse hematopoietic stem cells (HSCs) published Nestorowa et al., Blood(2016) [link](https://ashpublications.org/blood/article/128/8/e20/35749/A-single-cell-resolution-map-of-mouse).
- We will provide the SingleCellExperiment 
- The SingleCellExperiment (sce) object was downloaded and processed by following this vignette [link](http://bioconductor.org/books/3.17/OSCA.workflows/nestorowa-mouse-hsc-smart-seq2.html#ref-nestorowa2016singlecell).


```r
sce &lt;- readRDS("data/sceOBJ_Nestorowa_HSC.rds")
sce
```

```
## class: SingleCellExperiment 
## dim: 46078 1656 
## metadata(0):
## assays(2): counts logcounts
## rownames(46078): ENSMUSG00000000001 ENSMUSG00000000003 ...
##   ENSMUSG00000107391 ENSMUSG00000107392
## rowData names(3): GENEID SYMBOL SEQNAME
## colnames(1656): HSPC_025 HSPC_031 ... Prog_852 Prog_810
## colData names(5): cell.type FACS sizeFactor label cellType
## reducedDimNames(3): diffusion PCA UMAP
## mainExpName: endogenous
## altExpNames(1): ERCC
```

---
## Estimate trajectories by fitting principle curves
To find the trajectories we need to fit our high dimensional data onto a curve. This step is processed with the *slingshot* [link](https://bioconductor.org/packages/release/bioc/html/slingshot.html) package.

To run slingshot we need:
  * Our sce object: sce
  * Clusters: sce$label
  * Our choice of dimension reduction approach: *PCA*
  * To reduce computational load the adjacent 100 cells are aggregated into single point (approx_points=100)
  * To avoid connecting unrelated trajectories, OMEGA clustering is introduced (omega=TRUE). 
  

```r
library(slingshot)
sce.sling &lt;- slingshot(sce, cluster = sce$label, reducedDim = "PCA", approx_points = 100,
    omega = TRUE)
```

---
## Estimate trajectories by fitting principle curves


```r
colData(sce.sling)[1, 1:5]
```

```
## DataFrame with 1 row and 5 columns
##                     cell.type                        FACS sizeFactor    label
##                   &lt;lgCMatrix&gt;                    &lt;matrix&gt;  &lt;numeric&gt; &lt;factor&gt;
## HSPC_025 FALSE:FALSE:TRUE:... 27675.2:1.17991:1.12999:...   0.499986        3
##              cellType
##           &lt;character&gt;
## HSPC_025 Erythrocytes
```

---
## Extract informations for each trajectory

Slingshot has fitted principle curves. We now will embed these cruves in UMAP space *embedCurves()*. We can see the number o
lineages detected at this point. 

```r
embedded &lt;- embedCurves(sce.sling, "UMAP")

embedded@metadata$lineages
```

```
## $Lineage1
## [1] "8" "5" "9" "1" "2" "3" "4"
## 
## $Lineage2
## [1] "8" "5" "9" "1" "2" "6"
## 
## $Lineage3
## [1] "7"
```

---
## Estimate pseudotime

Once we have lineages, we can then find the position of each cell along these trajectories. This is estimating the pseudotime. 



```r
pseudo.paths &lt;- slingPseudotime(sce.sling)
head(pseudo.paths, 2)
```

```
##           Lineage1 Lineage2 Lineage3
## HSPC_025 111.82993       NA       NA
## HSPC_031  96.15939 99.77961       NA
```

It will be useful to combine these times, to find the shared time.


```r
avg_pseudoTime &lt;- rowMeans(pseudo.paths, na.rm = TRUE)
colData(sce.sling)$avg_pseudoTime &lt;- avg_pseudoTime
```

---
## Estimate pseudotime

Once we have the average pseudotime we can always project these values on to our UMAP. 


```r
plotUMAP(sce.sling, colour_by = "avg_pseudoTime")
```

![](Session3_files/figure-html/unnamed-chunk-97-1.png)&lt;!-- --&gt;

---
## Plotting principle curves
The *slingCurves()* function can fetch essential information of each principle curve. The results are inside a list, with each principle curve in an element. For each principle curve, we can extract the UMAP data and the order of cells for plotting.


```r
embedded_curve &lt;- slingCurves(embedded)

curve &lt;- lapply(embedded_curve, function(x) {
    dat &lt;- data.frame(x$s[x$ord, ])  # UMAP axis and the order of cells
    return(dat)
})
names(curve) &lt;- c("curve1", "curve2", "curve3")

head(curve$curve1)
```

```
##       UMAP1     UMAP2
## 1 -12.23250 0.6437628
## 2 -12.01319 0.7200463
## 3 -11.79388 0.7963086
## 4 -11.57455 0.8725464
## 5 -11.35521 0.9487473
## 6 -11.13585 1.0248888
```

---
## Plotting principle curves

We can now just add our curve information directly to our pseudotime UMAP plot using ggplot parameters *geom_path()*. 


```r
plotUMAP(sce.sling, colour_by = "avg_pseudoTime") + geom_path(data = curve$curve1,
    aes(x = UMAP1, y = UMAP2), color = "blue") + geom_path(data = curve$curve2, aes(x = UMAP1,
    y = UMAP2), color = "black") + geom_path(data = curve$curve3, aes(x = UMAP1,
    y = UMAP2), color = "red")
```

![](Session3_files/figure-html/unnamed-chunk-98-1.png)&lt;!-- --&gt;

---
## Refine the estimations
The results indicated that lineage 3 is an outlier. If we look back at our lineage information this contains cluster 7.


```r
embedded@metadata$lineages
```

```
## $Lineage1
## [1] "8" "5" "9" "1" "2" "3" "4"
## 
## $Lineage2
## [1] "8" "5" "9" "1" "2" "6"
## 
## $Lineage3
## [1] "7"
```

---
## Refine the estimations

We can remove cluster 7 and re-evaluate trajectories again. First we rerun the pseudotime estimation. 


```r
sce2 &lt;- sce[, colData(sce)$label != 7]
sce.sling2 &lt;- slingshot(sce2, cluster = sce2$label, reducedDim = "PCA", approx_points = 100,
    omega = TRUE)
pseudo.paths &lt;- slingPseudotime(sce.sling2)
avg_pseudoTime &lt;- rowMeans(pseudo.paths, na.rm = TRUE)
colData(sce.sling2)$avg_pseudoTime &lt;- avg_pseudoTime
```




---
## Refine the estimations

Next we extract out the princple curves again. 


```r
embedded &lt;- embedCurves(sce.sling2, "UMAP")
embedded_curve &lt;- slingCurves(embedded)
curve &lt;- lapply(embedded_curve, function(x) {
    dat &lt;- data.frame(x$s[x$ord, ])  # UMAP axis and the order of cells
    return(dat)
})
names(curve) &lt;- c("curve1", "curve2")
```

---
## Refine the estimations


```r
plotUMAP(sce.sling2, colour_by = "avg_pseudoTime") + geom_path(data = curve$curve1,
    aes(x = UMAP1, y = UMAP2), color = "blue") + geom_path(data = curve$curve2, aes(x = UMAP1,
    y = UMAP2), color = "black")
```

![](Session3_files/figure-html/unnamed-chunk-102-1.png)&lt;!-- --&gt;

---
## Trajectory and pseudotime for each lineage

So far we have visualized the lineages together. We will want to break this down and compare to clusters. First we will look at clusters. 


```r
plotUMAP(sce.sling2, colour_by = "label")
```

![](Session3_files/figure-html/sec3_trajANA_trajSep-1.png)&lt;!-- --&gt;

---
## Trajectory and pseudotime for each lineage

We can reveal which cluster belong to each cluster and lineage 1's trajectory. 


```r
embedded@metadata$lineages$Lineage1
```

```
## [1] "8" "5" "9" "1" "2" "3" "4"
```

```r
plotUMAP(sce.sling2, colour_by = "slingPseudotime_1") + geom_path(data = curve$curve1,
    aes(x = UMAP1, y = UMAP2))
```

![](Session3_files/figure-html/unnamed-chunk-103-1.png)&lt;!-- --&gt;

---
## Trajectory and pseudotime for each lineage

We can reveal which cluster belong to each cluster and lineage 2's trajectory. 


```r
embedded@metadata$lineages$Lineage2
```

```
## [1] "8" "5" "9" "1" "2" "6"
```

```r
plotUMAP(sce.sling2, colour_by = "slingPseudotime_2") + geom_path(data = curve$curve2,
    aes(x = UMAP1, y = UMAP2))
```

![](Session3_files/figure-html/unnamed-chunk-104-1.png)&lt;!-- --&gt;



---
## Identify driver genes for each lineage
Driver genes were the genes whose expression level changes reflect the pseudotime changes. We can find these using *testPseudotime()* from TSCAN. Using this the gene expression and pseudotime are fitted with a non-linear model, followed by testing with ANOVA.

We will start by just looking at lineage 1. 


```r
library(TSCAN)
res &lt;- testPseudotime(sce.sling2, sce.sling2$slingPseudotime_1)
```


---
## Identify driver genes for each lineage

We can see the results. Often we will want to reorder it too prioritize the biggest changers.


```r
res$SYMBOL &lt;- rownames(res)
res &lt;- res[order(-res$logFC), ]
head(res)
```

```
## DataFrame with 6 rows and 4 columns
##                        logFC      p.value          FDR             SYMBOL
##                    &lt;numeric&gt;    &lt;numeric&gt;    &lt;numeric&gt;        &lt;character&gt;
## ENSMUSG00000021728 0.0678996  0.00000e+00  0.00000e+00 ENSMUSG00000021728
## ENSMUSG00000016494 0.0654681  0.00000e+00  0.00000e+00 ENSMUSG00000016494
## ENSMUSG00000040747 0.0639249 7.23447e-296 5.16939e-293 ENSMUSG00000040747
## ENSMUSG00000057729 0.0619007  0.00000e+00  0.00000e+00 ENSMUSG00000057729
## ENSMUSG00000021998 0.0610830  0.00000e+00  0.00000e+00 ENSMUSG00000021998
## ENSMUSG00000090164 0.0608169 4.81695e-237 1.76510e-234 ENSMUSG00000090164
```

---
## Identify driver genes for each lineage

We can then categorize our data based on significance and FC.

* Recommend FDR threshold: 0.05
* The logFC reflects the trend of gene expression toward pseudotime. 
  + logFC &gt; 0, gene expression increased through increasing pseudotime [related to late stage]
  + logFC &lt; 0, gene expression decreased through increasing pseudotime [related to early stage]


```r
res$stat &lt;- NA
res$stat[res$logFC &gt; 0 &amp; res$FDR &lt; 0.05] &lt;- "late"
res$stat[res$logFC &lt; 0 &amp; res$FDR &lt; 0.05] &lt;- "early"
res$stat[is.na(res$stat)] &lt;- "nc"
res[1:2, ]
```

```
## DataFrame with 2 rows and 5 columns
##                        logFC   p.value       FDR             SYMBOL        stat
##                    &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;        &lt;character&gt; &lt;character&gt;
## ENSMUSG00000021728 0.0678996         0         0 ENSMUSG00000021728        late
## ENSMUSG00000016494 0.0654681         0         0 ENSMUSG00000016494        late
```

---
## Identify driver genes for each lineage

We can quickly and easily see how many are upregulated/downregulated across the trajectory. 


```r
table(res$stat)
```

```
## 
## early  late    nc 
## 11261  8848 25969
```

---
## Top driver genes

Using the order we can easily isolate the driver genes. Here we can see the top 5 early genes.


```r
sub &lt;- res[res$stat == "early", ]
sub &lt;- sub[order(sub$logFC), ]
top &lt;- head(sub$SYMBOL, 5)
top
```

```
## [1] "ENSMUSG00000054191" "ENSMUSG00000004655" "ENSMUSG00000027556"
## [4] "ENSMUSG00000031877" "ENSMUSG00000031162"
```

---
## Plotting top driver genes

With *plotExpression()* we can look at the expression of specific genes i.e. our top genes. We can see how each gene is expressed across all cells and psuedotime. 


```r
plotExpression(sce.sling2, features = top, swap_rownames = "GENEID", x = "slingPseudotime_1",
    colour_by = "label")
```

![](Session3_files/figure-html/unnamed-chunk-109-1.png)&lt;!-- --&gt;

---
## Plotting top driver genes

We can now repeat this for the top 5 late genes. 

```r
sub &lt;- res[res$stat == "late", ]
sub &lt;- sub[order(-sub$logFC), ]
top &lt;- head(sub$SYMBOL, 5)
plotExpression(sce.sling2, features = top, swap_rownames = "GENEID", x = "slingPseudotime_1",
    colour_by = "label")
```

![](Session3_files/figure-html/sec3_trajANA_driveL1_topLate2-1.png)&lt;!-- --&gt;

---
## Plotting top driver genes

We can now repeat this for the top 5 late genes. 
![](Session3_files/figure-html/sec3_trajANA_driveL1_topLate-1.png)&lt;!-- --&gt;

---
## Identify driver genes

Now lets repeat this whole process for lineage 2. 


```r
res &lt;- testPseudotime(sce.sling2, sce.sling2$slingPseudotime_2)
res$SYMBOL &lt;- rownames(res)
res &lt;- res[order(-res$logFC), ]
res$stat &lt;- NA
res$stat[res$logFC &gt; 0 &amp; res$FDR &lt; 0.05] &lt;- "late"
res$stat[res$logFC &lt; 0 &amp; res$FDR &lt; 0.05] &lt;- "early"
res$stat[is.na(res$stat)] &lt;- "nc"

table(res$stat)
```

```
## 
## early  late    nc 
## 11566  8450 26062
```

---
## Plotting top driver genes


```r
sub &lt;- res[res$stat == "early", ]
sub &lt;- sub[order(sub$logFC), ]
top &lt;- head(sub$SYMBOL, 5)
plotExpression(sce.sling2, features = top, swap_rownames = "GENEID", x = "slingPseudotime_1",
    colour_by = "label")
```

![](Session3_files/figure-html/sec3_trajANA_driveL2_topEarly-1.png)&lt;!-- --&gt;


## Plotting top driver genes

```r
sub &lt;- res[res$stat == "late", ]
sub &lt;- sub[order(-sub$logFC), ]
top &lt;- head(sub$SYMBOL, 5)
plotExpression(sce.sling2, features = top, swap_rownames = "GENEID", x = "slingPseudotime_1",
    colour_by = "label")
```

![](Session3_files/figure-html/sec3_trajANA_driveL2_topLate-1.png)&lt;!-- --&gt;





---
class: inverse, center, middle

# CITE-Seq 

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## CITE-Seq

The CITE-Seq method labels different types of cells or different samples with hashtag-labeled antibodies. Then, the cells can be pooled together into a single library and be sequencing at the same time. After sequencing, the cells can be separated by the different antibody hashtags.

- Here, we will use a dataset from Seurat vignette [link](https://satijalab.org/seurat/articles/hashing_vignette.html)

---
## Load data


```r
rna.mat &lt;- readRDS("data/pbmc_umi_mtx.rds")
dim(rna.mat)
```

```
## [1] 27117 16916
```

```r
hto.mat &lt;- readRDS("data/pbmc_hto_mtx.rds")
dim(hto.mat)
```

```
## [1]     8 16916
```

```r
rownames(hto.mat)
```

```
## [1] "HTO_A" "HTO_B" "HTO_C" "HTO_D" "HTO_E" "HTO_F" "HTO_G" "HTO_H"
```


---
## Prepare data


```r
seu_obj &lt;- CreateSeuratObject(counts = rna.mat, project = "citeSeq_demo")
seu_obj[["HTO"]] &lt;- CreateAssayObject(counts = hto.mat)
seu_obj
```

```
## An object of class Seurat 
## 27125 features across 16916 samples within 2 assays 
## Active assay: RNA (27117 features, 0 variable features)
##  1 layer present: counts
##  1 other assay present: HTO
```



---
## Cluster with regular workflow

```r
DefaultAssay(seu_obj) &lt;- "RNA"
seu_obj &lt;- data_proc(seu_obj)
seu_obj &lt;- ScaleData(seu_obj)
```

---
## Cluster with regular workflow


```r
seu_obj &lt;- quick_clust(seu_obj)
DimPlot(seu_obj, group.by = "seurat_clusters", pt.size = 0.2, label = TRUE) + NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-114-1.png)&lt;!-- --&gt;

---
## Differentiate Hashtags

- Normalize data with **centered log ratio (CLR)**
- Demultiplex HTOs with *HTODemux()*
- Threshold for positive call: *0.99 quantile*


```r
seu_obj &lt;- NormalizeData(seu_obj, assay = "HTO", normalization.method = "CLR")
seu_obj &lt;- HTODemux(seu_obj, assay = "HTO", positive.quantile = 0.99)

head(seu_obj, 2)
```

```
##                    orig.ident nCount_RNA nFeature_RNA nCount_HTO nFeature_HTO
## AGGCCACAGCGTCTAT citeSeq_demo        273          210       4200            7
## ATTGGTGAGTTCGCAT citeSeq_demo        305          174       3475            8
##                  RNA_snn_res.0.5 seurat_clusters HTO_maxID HTO_secondID
## AGGCCACAGCGTCTAT               1               1     HTO-H        HTO-E
## ATTGGTGAGTTCGCAT               0               0     HTO-H        HTO-G
##                  HTO_margin HTO_classification HTO_classification.global
## AGGCCACAGCGTCTAT 4.71133972              HTO-H                   Singlet
## ATTGGTGAGTTCGCAT 0.03995001        HTO-G_HTO-H                   Doublet
##                  hash.ID
## AGGCCACAGCGTCTAT   HTO-H
## ATTGGTGAGTTCGCAT Doublet
```

---
## Differentiate Hashtags


```r
table(seu_obj$HTO_classification.global)
```

```
## 
##  Doublet Negative  Singlet 
##     2598      346    13972
```

```r
table(seu_obj$hash.ID)
```

```
## 
##  Doublet    HTO-H    HTO-D    HTO-E    HTO-G    HTO-F    HTO-B    HTO-C 
##     2598     1808     1716     1487     1660     1520     1993     1873 
##    HTO-A Negative 
##     1915      346
```


---
## Evaluate HTOs

```r
RidgePlot(seu_obj, group.by = "hash.ID", assay = "HTO", features = rownames(seu_obj[["HTO"]])[1:2],
    ncol = 2)
```

![](Session3_files/figure-html/sec3_CITE_ridget-1.png)&lt;!-- --&gt;

---
## Evaluate HTOs

```r
RidgePlot(seu_obj, group.by = "hash.ID", assay = "HTO", features = rownames(seu_obj[["HTO"]])[3:4],
    ncol = 2)
```

![](Session3_files/figure-html/unnamed-chunk-116-1.png)&lt;!-- --&gt;




---
class: inverse, center, middle

# SMART-Seq 

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## SMART-seq - a 10X alternative

[Schema](https://user-images.githubusercontent.com/40051862/112074504-abfcda80-8b33-11eb-86d7-45215fd1291a.png)

---
## SMART-seq - a 10X alternative

* Pros
  + Full-length coverage of transcripts
  + Increased depth
  + Differential transcript usage
  
* Cons
  + Much more expensive
  + More complicate bench work
  
* Applications
  + Generic clustering
  + Differential gene expression
  + Alternative splicing

---
## Demo data

- Single-cell quantification of a broad RNA spectrum reveals uniqure noncoding patterns associated with cell types and states. Isaknova A, Neff N, and Quake SR, PNAS (2021). [link](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8713755/)

- Counting matrix of mouse embryo data was download from [GEO GSE151334](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE151334).

- Data process workflow was recorded on GitHub. [link](https://github.com/aisakova/smart-seq-total/tree/master)

---
## Alignment and counting

* The SMART-Seq data pre-processing is quite similar to bulk RNA-seq, including **align to reference genome** and **counting**. There are two strategy to process from FQ files.
  + Align to reference genome by using **STAR** and then make counting with **featureCounts** [like this demo data].
  + Pseudo-alignment and counting by using **salmon** and then gathering counting matrix with **tximport**.
  
* Details of the two methods can be found in the BRC training course. Please refer to this [link](https://rockefelleruniversity.github.io/RU_RNAseq/).

---
## Read count matrix (in tsv file) into matrix


```r
mtx &lt;- read.delim("data/GSE151334_counts.mouse.tsv.gz")
mtx[1:2, 1:5]
```

```
##               mESC_EB_d0_A11_S11 mESC_EB_d0_A12_S12 mESC_EB_d0_A13_S13
## 0610005C13Rik                  0                  0                  0
## 0610006L08Rik                  0                  0                  0
##               mESC_EB_d0_A14_S14 mESC_EB_d0_A15_S15
## 0610005C13Rik                  0                  0
## 0610006L08Rik                  0                  0
```

---
## Load matrix into Seurat object

Once we have loaded the matrix, we can create a Seurat object. After this point we will be following a similar workflow to the 10X data. Here we start by finidng the mitochondrial content. 


```r
library(Seurat)
seu &lt;- CreateSeuratObject(mtx, project = "GSE151334", min.cells = 3, min.features = 300)
seu[["percent.mt"]] &lt;- PercentageFeatureSet(seu, pattern = "^mt-")
seu &lt;- SCTransform(seu, variable.features.n = 2000)
```



---
## Assess doublets




```r
library(reticulate)
reticulate::py_install("scrublet")
scr &lt;- reticulate::import("scrublet")

mat &lt;- GetAssayData(seu, assay = "RNA", slot = "counts")
mat &lt;- as.matrix(mat)
scr &lt;- reticulate::import("scrublet")
scrub &lt;- scr$Scrublet(t(mat))
doublet &lt;- scrub$scrub_doublets()
names(doublet) &lt;- c("doublet_score", "doublet")
seu[["doublet_score"]] &lt;- doublet$doublet_score
seu[["doublet"]] &lt;- doublet$doublet
```

---
## Estimate cell cycle phases

Lets read in annotated cell cycle genes from the Regev lab. This list of genes was curated by the authors of Seurat, and is a subset of the genes used in the original Cell Cycle paper.



---
## Data normalization and quick clustering


```r
set.seed(42)
seu &lt;- RunPCA(seu, npcs = 50, verbose = FALSE)
seu &lt;- FindNeighbors(seu, dims = 1:15, reduction = "pca")
seu &lt;- RunUMAP(seu, dims = 1:15, reduction = "pca")
seu &lt;- FindClusters(seu, resolution = 0.5)
```






---
## Quality assessment

We can see here that this is a highly variable dataset. We can also see that there are some cells with high mitochondrial content in some samples. We will filter these out later.



```r
library(ggplot2)
VlnPlot(seu, features = c("nCount_RNA", "nFeature_RNA", "percent.mt", "doublet_score",
    "S.Score", "G2M.Score"), group.by = "seurat_clusters")
```

![](Session3_files/figure-html/SMARTSeq_quickClust-1.png)&lt;!-- --&gt;


---
## Quality assessment


```r
FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "seurat_clusters")
```

![](Session3_files/figure-html/unnamed-chunk-123-1.png)&lt;!-- --&gt;



---
## Quality assessment

Another view of our high mitochondrial content. 


```r
FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "percent.mt", group.by = "seurat_clusters") +
    geom_hline(yintercept = 10, color = "black", linetype = "dashed")
```

![](Session3_files/figure-html/unnamed-chunk-124-1.png)&lt;!-- --&gt;

---
## Quality assessment


```r
table(seu$doublet == "TRUE" | seu$percent.mt &gt; 10)
```

```
## 
## FALSE  TRUE 
##  1559   373
```

---
## Filtering low quality cells


```r
set.seed(42)
seu &lt;- subset(seu, subset = percent.mt &lt;= 10 &amp; doublet == "FALSE")
seu &lt;- SCTransform(seu, variable.features.n = 2000, vars.to.regress = c("percent.mt"))
seu &lt;- RunPCA(seu, npcs = 50, verbose = FALSE)
seu &lt;- RunUMAP(seu, dims = 1:15, reduction = "pca")
seu &lt;- FindNeighbors(seu, dims = 1:15, reduction = "pca")
seu &lt;- FindClusters(seu, resolution = 0.5)
```

```
## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck
## 
## Number of nodes: 1559
## Number of edges: 42165
## 
## Running Louvain algorithm...
## Maximum modularity in 10 random starts: 0.8941
## Number of communities: 10
## Elapsed time: 0 seconds
```

---
## Filtering low quality cells


```r
DimPlot(seu, group.by = "seurat_clusters", pt.size = 0.2, label = TRUE) + NoLegend()
```

![](Session3_files/figure-html/unnamed-chunk-126-1.png)&lt;!-- --&gt;

---
## Marker genes by clusters


```r
markers &lt;- FindAllMarkers(seu, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
library(dplyr)
top_genes &lt;- markers %&gt;%
    group_by(cluster) %&gt;%
    slice_max(n = 5, order_by = avg_log2FC)
```









---
## Marker genes by clusters
  

```r
DoHeatmap(seu, features = c(top_genes$gene))
```

![](Session3_files/figure-html/unnamed-chunk-129-1.png)&lt;!-- --&gt;


---
## Add annotation by using known marker genes



```r
VlnPlot(seu, features = c("Nanog", "Pou5f1"), ncol = 2, pt.size = 0)
```

![](Session3_files/figure-html/SMARTSeq_markExp-1.png)&lt;!-- --&gt;

---
## Add annotation by using known marker genes



```r
VlnPlot(seu, features = c("Pax6", "Stau2"), ncol = 2, pt.size = 0)
```

![](Session3_files/figure-html/SMARTSeq_markExp2-1.png)&lt;!-- --&gt;


---
## Add annotation by using known marker genes


```r
VlnPlot(seu, features = c("Epcam", "Gata6"), ncol = 2, pt.size = 0)
```

![](Session3_files/figure-html/SMARTSeq_markExp3-1.png)&lt;!-- --&gt;


---
## Add annotation by using known marker genes


```r
VlnPlot(seu, features = c("Dlk1", "Postn"), ncol = 2, pt.size = 0)
```

![](Session3_files/figure-html/SMARTSeq_markExp4-1.png)&lt;!-- --&gt;



---
## Add annotation by using known marker genes


```r
seu[["layers"]] &lt;- NA
seu$layers[seu$seurat_clusters %in% c(0, 4, 5)] &lt;- "primary_ES"
seu$layers[seu$seurat_clusters %in% c(2, 3, 10, 11, 12)] &lt;- "ectoderm"
seu$layers[seu$seurat_clusters %in% c(1, 9)] &lt;- "mesoderm"
seu$layers[seu$seurat_clusters %in% c(6, 7, 8)] &lt;- "endoderm"
```

---
## Add annotation by using known marker genes


```r
DimPlot(seu, group.by = "layers", pt.size = 0.2)
```

![](Session3_files/figure-html/unnamed-chunk-131-1.png)&lt;!-- --&gt;




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
