---
title: "Single-cell RNA sequencing ~ Session 3<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "https://rockefelleruniversity.github.io/scRNA-seq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r setup, include=FALSE}
suppressPackageStartupMessages(require(knitr))
suppressPackageStartupMessages(require(DropletUtils))
suppressPackageStartupMessages(require(SingleCellExperiment))
suppressPackageStartupMessages(require(scran))
suppressPackageStartupMessages(require(scater))
suppressPackageStartupMessages(require(scuttle))
suppressPackageStartupMessages(require(scDblFinder))
knitr::opts_chunk$set(echo = TRUE, tidy = T, fig.height=4, fig.width=7)
```

```{r sec3_loadPack,include=F,eval=FALSE}
library(Seurat)
library(scran)
library(scater)
library(SeuratData)
library(batchelor)
library(ggplot2)
library(pheatmap)
library(slingshot)
library(TSCAN)
library(SoupX)
library(DropletUtils)
library(scuttle)
```

---
## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)

---
# Outlines
- Merge multiple data sets - 4 different approaches for this
- Droplet processing - 3 different approaches for this
- Pseudotime analysis with slingshot
- CITE-seq data processing

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merging Datasets

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merging Datasets

---
"    
  )
  
}

```

## Merge multiple datasets
We will discuss a number of approaches and methods we may need to use to merge datasets.

- No corrections
- Reciprocal Principle Component Analysis (RPCA)
- Mutual Nearest Neighbors (MNN)
- Harmony


---
## Example dataset

We will be using the IFNB-Stimulated and Control PBMCs from Seurat Data. The easiest way to get this data is from their custom package *SeuratData* which is hosted on GitHub. 

We will quickly show you how to get this data, but it isn't necessary to run these steps. 

```{r, eval=F}
devtools::install_github('satijalab/seurat-data')
```

```{r}
library(Seurat)
library(SeuratData)
InstallData("ifnb")
LoadData("ifnb")
head(ifnb,2)
```

---
## Example dataset

This dataset is already loaded in as a Seurat object, and it is already merged. So we need to split it, so we can merge it ourselves! The groups are in the "stim" column of the metadata.

```{r sec3_mergeData_fetchEG,include=TRUE, eval=F}
table(ifnb$stim)
ifnb_list <- Seurat::SplitObject(ifnb, split.by="stim")
ifnb_list
```

```{r, echo=F, eval=F}
save("ifnb_list",
     file = "data/seuOBJ_IFNB_splitByStim.RData")
```

---
## Load in your dataset

We have the ifnb_list save in an RData object, which you can load in. 

```{r}
load("data/seuOBJ_IFNB_splitByStim.RData")

```

---
## Create some functions for quick analysis later
We are going to try out a few merging approaches. We want to wrap some of our analysis steps into a function to simplify rerunning things.

Normalization: 
  * Log normalization with scale factor = 10,000
  * Find Variable features with vst, select top 2000 variable features
  
```{r sec_mergeData_funcUsed_dataProc,include=TRUE}
data_proc <- function(seu){
  seu <- NormalizeData(seu,normalization.method="LogNormalize",scale.factor=10000)
  seu <- FindVariableFeatures(seu,select.method="vst",nfeatures=2000)
  return(seu)}
```

---
## Create some functions for quick analysis later

Make clusters:
  * Scale data with *ScaleData()*
  * Principle Component Analysis by using *RunPCA()* with npcs=30 PCs
  * Make non-linear dimensional reduction in UMAP by using *RunUMAP()* with dims=1:10
  * Estimate Neighbors by using *FindNeighbors()* with dims=1:10
  * Identify clusters with *FindClusters()* by using resolution=0.5
  
```{r sec3_mergeData_funcUsed_quickClust,include=TRUE}
quick_clust <- function(seu){
  set.seed(1001)
  seu <- ScaleData(seu,verbose=FALSE)
  seu <- RunPCA(seu,npcs=30,verbose=FALSE)
  seu <- RunUMAP(seu, reduction = "pca", dims = 1:10,verbose=FALSE)
  seu <- FindNeighbors(seu, reduction = "pca", dims = 1:10,verbose=FALSE)
  seu <- FindClusters(seu, resolution = 0.5,verbose=FALSE)
  return(seu)}
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Simple Merge

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Simple Merge

---
"    
  )
  
}

```

## Concatenate the datasets

We can use *merge()* function to integrate our two data sets, as they are. We need to provide Group information and a name for the project as arguments. 

```{r mergeData_woCor_merged,include=TRUE,eval=T}

ifnb_merge <- merge(ifnb_list$CTRL, ifnb_list$STIM,
                            add.cell.ids = c("CTRL","STIM"), project = "ifnb_seuMerge")
head(ifnb_merge,2)
```

---
## Process and make clusters
We can use our processing and clustering functions to analyse our merged dataset. 

```{r sec3_mergeData_woCorr_cluster,include=TRUE}
ifnb_merge <- data_proc(ifnb_merge)
ifnb_merge <- quick_clust(ifnb_merge)
```

---
## UMAP

Our UMAP shows our cells are distinct, depending on the condition. 

```{r}
DimPlot(ifnb_merge,group.by = "stim", pt.size = 0.2)
```

---
## Evaluate with cell types
A given cell type should often be clustered together. This pattern indicates the opposite. Different cell types are split into distinct groups depending on the sample.

```{r sec3_mergeData_woCorr_eval,include=TRUE}

DimPlot(ifnb_merge, group.by = "seurat_annotations", pt.size = 0.2,split.by = "stim")

```

---
## STIM/CTRL are not grouped together

* This result indicates the difference between STIM and CTRL groups is huge.
* Is this a true biological phenomena or is it a batch effect?

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merge with reciprocal PCA

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merge with reciprocal PCA

---
"    
  )
  
}

```

## Merge data with reciprocal PCA (RPCA)
Reciprocal PCA minimizes the batch effects while merging different data sets.

This workflow is modified from canonical correlation analysis (CCA), which is widely used to merge batches.

---
## RPCA workflow

  1. Normalize data sets. We can use our *data_proc()*. 
  2. Select features for integration by using *SelectIntegrationFeatures()*.
  3. Scale data and process PCA by using the features identified for integration
  4. Identify Anchors for integration by using *FindIntegrationAnchors()*
  5. Integrate data by using *IntegratedData()*
  6. Process *quick_cluster()* and evaluate results with UMAP

---  
## Prepare for RPCA merge

First, we prepare the data for integration. We will normalize the data sets separately. Than, we need to identify features for integration. This is similar to the VariableFeatures function we ran on a single dataset. Lastly we run scaling and PCA, using these features.

```{r sec3_mergeData_RPCA_prep,include=TRUE,eval=T}

ifnb_list_rpca <- lapply(ifnb_list, data_proc)

feats <- SelectIntegrationFeatures(ifnb_list_rpca)

ifnb_list <- lapply(ifnb_list,function(seu,feats){
  seu <- ScaleData(seu,features=feats,verbose=FALSE)
  seu <- RunPCA(seu,features=feats,verbose=FALSE)
  return(seu)},feats)
```

---
## Integrating data in RPCA merge

We can then identify anchors. These are the features through which we will integrate our data. Once we have these features, we can then integrate our data sets together.

```{r sec3_mergeData_RPCA_int,include=TRUE,eval=T}
anchors <- FindIntegrationAnchors(ifnb_list, anchor.features = feats, reduction = "rpca")

ifnb_merge <- IntegrateData(anchorset = anchors)

ifnb_merge
```

---
## Evaluating RPCA merge using clusters

To evaluate how well the merge has worked we must check the clustering. Again we must scale, and then use our *quick_clust* function. 

We can now see that our two data sets overlay with each other.

```{r sec3_mergeData_RPCA_cluster,include=TRUE,eval=F}

ifnb_merge <- ScaleData(ifnb_merge)

ifnb_merge <- quick_clust(ifnb_merge)

DimPlot(ifnb_merge,group.by = "stim",pt.size = 0.2)
```

---
## Evaluating RPCA merge using clusters

We can now see that our two data sets overlay with each other.

```{r sec3_mergeData_RPCA_cluster2,include=TRUE,eval=T, echo=F}

ifnb_merge <- ScaleData(ifnb_merge)

ifnb_merge <- quick_clust(ifnb_merge)

DimPlot(ifnb_merge,group.by = "stim",pt.size = 0.2)
```

---
## Evaluating RPCA merge using clusters

We can check the numbers in each cluster. Broadly, there are similar numbers per cluster now. 

```{R}
tbl <- table(ifnb_merge$stim, ifnb_merge$seurat_clusters)

barplot(tbl,beside = T, main= "Cell numbers in each cluster of each group")
```

---
## Evaluating RPCA merge using cell types

We can also check the cell types. Using UMAPs we can split and compare across our conditions and cell types. 

```{r sec3_mergeData_RPCA_eval,include=TRUE,eval=T}

DimPlot(ifnb_merge, group.by = "seurat_annotations", split.by= "stim", pt.size = 0.2)
```

---
## Evaluating RPCA merge using cell types

Using heatmaps we can also check how specific each cluster is to each cell type.

```{R}
library(pheatmap)

tbl <- table(ifnb_merge$seurat_clusters,ifnb_merge$seurat_annotations)
pheatmap(tbl, scale = "column")

```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merge data with MNN correction

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merge data with MNN correction

---
"    
  )
  
}

```


## Merge data with Mutual Nearest Neighbors (MNN) correction

Mutual Nearest Neighbors approach uses paired cells instead of anchor genes to find the difference between batches. 

The MNN correction was published by Marioni et al, Nature (2018). [link](https://www.nature.com/articles/nbt.4091)

---
## Steps for merging data with MNN

1. Convert into SingleCellExperiment
2. Identify features across samples
3. Normalization
4. Identify variables
5. Merge data with MNN correction
6. Build UMAP and clusters
7. Evaluate with UMAP
8. Evaluate composition of samples in each cluster

---
## Preparing to merge data with MNN 

First we have to convert Seurat object to SingleCellExperiment object.

```{r sec3_mergeData_MNN_prep,include=TRUE,eval=T}

sce_list <- lapply(ifnb_list,function(seu){
  sce <- as.SingleCellExperiment(seu,assay="RNA")
  rowData(sce)$SYMBOL <- rownames(sce)
  return(sce)})


sce_list 
```

---
## Preparing to merge data with MNN 

As with RPCA we need to model and identify highly variable genes. For this we will use the scran functions *modelGeneVar()* and *getTopHVGs()*. We simply provide our SingleCellExperiment object.

```{r}
library(scran)
dec_list <- lapply(sce_list, modelGeneVar)

hvgc_list <-lapply(sce_list, getTopHVGs ,prop=0.1)
```

---
## Preparing to merge data with MNN 

Next we will find the features that are shared between samples. We must first define the shared "universe" of genes between our samples, and subset our variable genes to these. We can then combine the the variance to find variable features in both data sets. 

```{r}
universe <- intersect(rownames(sce_list$CTRL),rownames(sce_list$STIM))
sce_list <- lapply(sce_list,function(sce,universe){
  sce <- sce[universe,];return(sce)},universe)
dec_list <- lapply(dec_list,function(dec,universe){
  dec <- dec[universe,];return(dec)},universe)

combined_dec <- combineVar(dec_list$CTRL, dec_list$STIM)
chosen_hvgs <- combined_dec$bio > 0
```

---
## Merge data with MNN
We will use the batchelor package to run MNN with the *fastMNN()* function. 
  * d: number of principles evaluated
  * k: number of nearest neighbors to consider
  * subset.row: subset genes. Here, we are using the top variable features

  
```{r sec3_mergeData_MNN_cor,include=TRUE,eval=T}
library(batchelor)
mnn_res <- fastMNN("CTRL"=sce_list$CTRL, "STIM"=sce_list$STIM,
                   d=50, 
                   k=20,
                   subset.row=chosen_hvgs)
mnn_res
```

---
## Merge data with MNN

The resulting SingleCellExperiment object contains the batch information. We can also retrieve a matrix of our dimension reduction results and corrected log counts with the *reducedDim()* and *assay()* functions. 

```{R}
table(mnn_res$batch)
```

```{r}
reducedDim(mnn_res,"corrected")[1:2,]
```

```{r}
assay(mnn_res,"reconstructed")[1:2,1:5]
```

---
## UMAP of data merged with MNN 

Make UMAP using the scater package.

```{r sec3_dataMerge_MNN_cluster,include=TRUE,eval=T}
library(scater)
set.seed(1001)
mnn_res <- runUMAP(mnn_res, dimred="corrected")
mnn_res$batch <- factor(mnn_res$batch)
plotUMAP(mnn_res, colour_by="batch")
```

---
## Clustering data merged with MNN 

We will cluster using SNN graph approach from scran as this is comptaible with our SingleCellExperiment object. 

```{r}
snn.gr <- buildSNNGraph(mnn_res,use.dimred="corrected")
cluster_mnn <- igraph::cluster_louvain(snn.gr)$membership
table(cluster_mnn)
```

---
## Clustering data merged with MNN 

Lets check the UMAP for our clustered results.

```{R}
mnn_res$cluster <- factor(cluster_mnn)
plotUMAP(mnn_res,colour_by="cluster")
```

---
## Clustering data merged with MNN 

We can also check how many cells from each cluster belong to each group. With this approach you can see that there is a lot more group-specific clusters.

```{r}

tbl <- table(mnn_res$batch,mnn_res$cluster)
barplot(tbl,beside = T, main= "Cell numbers in each cluster of each group")
```

---
## Evaluate with cell types

We must annotate our SingleCellExperiment object with different cell type information. We can then visualize the cell types on our UMAP. 

```{r sec3_dataMerge_MNN_eval,include=TRUE,eval=T}

cellType <- lapply(sce_list,function(x){
  res <- setNames(as.character(colData(x)$seurat_annotations),colnames(x))
  return(res)})
cell_type <- c(cellType$CTRL,cellType$STIM)
mnn_res$cell_type <- cell_type[match(rownames(colData(mnn_res)),names(cell_type))]
mnn_res$cell_type <- factor(mnn_res$cell_type)
```

```{r}
plotUMAP(mnn_res,colour_by="cell_type")
```

---
## Evaluate with cell types

```{r}

plotUMAP(mnn_res,colour_by="cell_type")
```

---
## Evaluate with cell types

We can also  use a heatmap to look at the specificity of each cell type to each cluster. Most are cluster-specific.

```{r}
tbl <- table(mnn_res$cluster, mnn_res$cell_type)
pheatmap(tbl,scale = "column")

```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merge data with Harmony

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merge data with Harmony

---
"    
  )
  
}

```


## Harmony
- Harmony is an R package for single-cell data integration [liike](https://www.nature.com/articles/s41592-019-0619-0).
- The user manual of Harmony is also available [link](https://portals.broadinstitute.org/harmony/articles/quickstart.html).
- There is also a python implementation of this package. 
- Here, we will demonstrate how to integrate harmony into Seurat regular workflow.

---
## Prepare data for Harmony
We can prepare for Harmony in much the same way as we prepare for the simple Seurat merge: merge, normalize, scale, PCA and UMAP.

```{r sec3_mergedata_Harmony_samplePrep,include=TRUE,eval=T}

seu_obj <- merge(ifnb_list$CTRL, ifnb_list$STIM)
seu_obj <- data_proc(seu_obj)
seu_obj <- ScaleData(seu_obj)
seu_obj <- RunPCA(seu_obj)
seu_obj <- RunUMAP(seu_obj, reduction = "pca", dims = 1:10, reduction.name = "umap")
```

---
## Prepare data for Harmony

As you can see we are back with our completely seperate groups. 

```{r}
DimPlot(seu_obj)
```

---
## Merge data with Harmony

We can use the *RunHarmony()* function to implement the Harmony correction. 

```{r sec3_mergedata_Harmony_merge,include=TRUE,eval=FALSE}
library(harmony)
seu_obj <- RunHarmony(seu_obj, group.by.vars = "stim", assay.use= "RNA")
seu_obj <- RunUMAP(seu_obj, reduction = "harmony", dims = 1:10, reduction.name = "umap_harmony")
DimPlot(seu_obj, reduction = "umap_harmony")
```

```{r, echo=F, eval=T, warning=F, message=FALSE, include=F}

rm(seu_obj, ifnb, ifnb_list, ifnb_merge, ifnb_list_rpca, feats, anchors, sce_list, dec_list, hvgc_list, combined_dec, chosen_hvgs, mnn_res, snn.gr, cluster_mnn ,cellType )
gc()
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Cell type annotation

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Cell type annotation

---
"    
  )
  
}

```

## Cell type annotation
To annotate the Single-cell data sets, we can evaluate the gene expression pattern of well known cell-type specific marker genes and make a manual annotation, like we did in section II. Here, we will introduce two more strategies to make cell type annotations automatically:
  1. Mapping and annotating query datasets with Seurat using a reference data set.  [link](https://satijalab.org/seurat/articles/integration_mapping.html)
  2. Make annotation with SingleR [link](https://bioconductor.org/packages/release/bioc/html/SingleR.html)

---
## Prepare example datasets

* The demo data, *panc8*,  was fetched by using SeuratData(). It contains single-cell RNA-Seq of human pancreatic islet sequenced with different techniques.
* The demo data contains
  + CELSeq dataset1 (*GSE81076*), as reference
  + CELSeq dataset2 (*GSE85241*), as reference
  + SMART-Seq2 (*E-MTAB-5061*), as reference
  + Fluidigm C1 (*GSE86469*), as query
  
```{r sec3_ctAnno_prepDemo_loadData,include=TRUE,eval=T}
library(Seurat)
library(SeuratData)
InstallData("panc8")
data("panc8")
head(panc8,2)
```


---
## Prepare example datasets

Split up the datasets by techniques using *SplitObject()*.

```{R}
seu_list <- SplitObject(panc8, split.by = "tech")
names(seu_list) <- c("celseq1", "celseq2", "smartseq", "fluidigmc1", "indrop")
```

---
## Prepare reference dataset
Merge celseq1 and celseq2 data with RPCA

```{r sec3_ctAnno_prepDemo_buildREF,include=TRUE,eval=T}

seu_list <- lapply(seu_list, data_proc)
ref_list <- seu_list[c("celseq1","celseq2")]
feats <- SelectIntegrationFeatures(ref_list)
ref_list <- lapply(ref_list,function(seu,feats){
  seu <- ScaleData(seu,features=feats,verbose=FALSE)
  seu <- RunPCA(seu,features=feats,verbose=FALSE)
  return(seu)},feats)
```

---
## Prepare reference dataset
Merge celseq1 and celseq2 data with RPCA

```{r sec3_ctAnno_Seurat_RPCA,include=TRUE,eval=T}

anchors <- FindIntegrationAnchors(ref_list,anchor.features = feats,reduction = "rpca")
ref_panc <- IntegrateData(anchorset = anchors)
ref_panc <- ScaleData(ref_panc)
ref_panc <- quick_clust(ref_panc)
```

---
## Prepare reference dataset

How does the data look?
```{R}
DimPlot(ref_panc,group.by = "seurat_clusters",split.by = "tech",pt.size = 0.2,label=TRUE)
```

---
## Gathering reference and query datasets

```{r sec3_ctAnno_Seurat_gatherData,include=TRUE,eval=T}

panc_list <- list("ref"=ref_panc,"query"=seu_list$smartseq)
feats <- SelectIntegrationFeatures(panc_list)
panc_list <- lapply(panc_list,function(seu,feats){
  seu <- ScaleData(seu,features=feats,verbose=FALSE)
  seu <- RunPCA(seu,features=feats,verbose=FALSE)
  return(seu)},feats)
```

---
## Predict cell types for query

Identify the anchors between reference and query data sets, using *FindTransferAnchors()*. These are essential to transfer information from our reference to our query. We can then transfer the cell type information. For each cell in query dataset, the score for each given cell type was estimated by the gene expression pattern of anchor genes using the *TransferData()* function. 

```{r sec3_ctAnno_Seurat_tranferAnno,include=TRUE,eval=T}
anchors <- FindTransferAnchors(reference = panc_list$ref,
                               query=panc_list$query,
                               dims=1:30,reference.reduction="pca")
pred_res <- TransferData(anchorset = anchors,refdata=panc_list$ref$celltype)
head(pred_res,2)
```

---
## Predict cell types for query
The cell type with highest score was assigned to the given cell. We can visualize this score with a heatmap. 

```{r}
mat <- as.matrix(pred_res[,-c(1,15)])
colnames(mat) <- gsub("prediction.score.","",colnames(mat))
pheatmap::pheatmap(mat,scale = "row",show_rownames = FALSE)
```

---
## Load cell types into query

```{r sec3_ctAnno_Seurat_pres,include=TRUE,eval=T}

pred_cellType <- setNames(pred_res$predicted.id, rownames(pred_res))
panc_list$query[["cellType_predBySeurat"]] <- pred_cellType[match(Cells(panc_list$query),
                                                                  names(pred_cellType))]

head(panc_list$query,2)

table(panc_list$query$cellType_predBySeurat)
```

---
## Annotation with SingleR
[SingleR](https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html) is bioconductor package which can be used to predict annotations of a single-cell dataset.

This package uses SingleCellExperiment objects, so we need to convert our Seurat object.

```{r sec3_ctAnno_SingleR_pred,include=TRUE,eval=T}
sce_list <- lapply(panc_list, function(seu){
  sce <- as.SingleCellExperiment(seu, assay="RNA")
  return(sce)})

```

---
## Annotation with SingleR

The score is generated comparing the expression levels of a cell in query dataset and the expression pattern of certain group (eg. cell types) in reference dataset. A cell would be assigned as the cell type which has highest score.

```{R}
library(SingleR)
pred_res <- SingleR(ref = sce_list$ref, test = sce_list$query, labels = sce_list$ref$celltype)
head(pred_res,2)
```

---
## Annotation with SingleR
By converting to a matrix, we can check the cell type scoring using a heatmap. 

```{r}
mat <- as.matrix(pred_res$scores)
rownames(mat) <- rownames(pred_res)
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE)
```

---
## Import SingleR annotation into query

Lastly we want to add our annotation back to our query dataset. 

```{r sec3_ctAnno_SingleR_import,include=TRUE,eval=T}
cell_type <- setNames(pred_res$pruned.labels,rownames(pred_res))
panc_list$query$cellType_predBySingleR <- cell_type[match(Cells(panc_list$query),names(cell_type))]
head(panc_list$query,2)

```


---
## Seurat vs SingleR annotation

First we can compare this back to the original annotation. We will look for how many overlap.

Seurat annotation:
```{r}
table(panc_list$query$cellType_predBySeurat == panc_list$query$celltype)
```

SingleR annotation:
```{r}
table(panc_list$query$cellType_predBySingleR == panc_list$query$celltype)
```

---
## Seurat vs SingleR annotation

Next we can compare our two annotations:

```{R}

table(panc_list$query$cellType_predBySeurat == panc_list$query$cellType_predBySingleR)
tbl <- table(panc_list$query$cellType_predBySeurat,panc_list$query$cellType_predBySingleR)
pheatmap::pheatmap(tbl,scale = "row")
```

```{r, echo=F, eval=T, warning=F, message=FALSE, include=F}

rm(panc8, seu_list, ref_list, feats, anchors, ref_panc, panc_list, seu, pred_res, mat, pred_cellType, sce_list, cell_type)
gc()
```

```{r, echo=F, eval=T, warning=F, message=FALSE, include=F}

rm(sce.sling2)
rm(res, embedded, embedded_curve,sce2, pseudo.paths, avg_pseudoTime, curve, sce.sling, sce, tbl, panc_list, cell_type, mat, pred_res,sce_list,pred_cellType,anchors,ref_panc,feats,ref_list,seu_list,panc8, seu_obj,mnn_res,cell_type,snn.gr,cluster_mnn,universe,sce_list,sce,dec_list,dec,combined_dec,chosen_hvgs,hvgc_list,anchors,ifnb_merge,ifnb_list,feats,ifnb_list_rpca ,ifnb)
gc()


```


