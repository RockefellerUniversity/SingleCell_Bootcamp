---
title: "Single-cell RNA sequencing ~ Session 3 <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Center"
date: "https://rockefelleruniversity.github.io/SingleCell_Bootcamp/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r setup, include=FALSE}
suppressPackageStartupMessages(require(knitr))
suppressPackageStartupMessages(require(DropletUtils))
suppressPackageStartupMessages(require(SingleCellExperiment))
suppressPackageStartupMessages(require(scran))
suppressPackageStartupMessages(require(scater))
suppressPackageStartupMessages(require(scuttle))
suppressPackageStartupMessages(require(scDblFinder))
knitr::opts_chunk$set(echo = TRUE, tidy = T, fig.height=4, fig.width=7, warning = F, message=F)
```

```{r sec3_loadPack,include=F,eval=FALSE}
library(Seurat)
library(scran)
library(scater)
library(ggplot2)
library(pheatmap)
library(TSCAN)
library(SoupX)
library(DropletUtils)
library(scuttle)
```

## Outlines

- Merge multiple data sets
- Cell Type Annotation 
- CITE-seq data processing


---
## A more advanced scRNAseq workflow

![overview](./imgs/scRNA_workflow_ver001_20231017.png)


## A more advanced scRNAseq workflow

Full image here of workflow is here: [overview](./imgs/scRNA_workflow_ver001_20231017.png)

scRNA seq is a very variable process and each dataset has unique QC problems. Though our simplified approach often works, we also need many more tools in our toolbox to handle more complex datasets. Often it is a case of trial and error to see what approaches work best for your data.

---
## Create some functions

We are going to try out a few tools and approaches. We want to wrap some of our analysis steps into a function to simplify rerunning things.

Normalization: 
  * Log normalization with scale factor = 10,000
  * Find Variable features with vst, select top 2000 variable features
  
```{r sec_mergeData_funcUsed_dataProc,include=TRUE}
data_proc <- function(seu){
  seu <- NormalizeData(seu, normalization.method="LogNormalize", scale.factor=10000)
  seu <- FindVariableFeatures(seu, select.method="vst", nfeatures=2000)
  return(seu)}
```

---
## Create some functions

Make clusters:
  * Scale data with *ScaleData()*
  * Principle Component Analysis by using *RunPCA()* with npcs=30 PCs
  * Make non-linear dimensional reduction in UMAP by using *RunUMAP()* with dims=1:10
  * Estimate Neighbors by using *FindNeighbors()* with dims=1:10
  * Identify clusters with *FindClusters()* by using resolution=0.5
  
```{r sec3_mergeData_funcUsed_quickClust,include=TRUE}
quick_clust <- function(seu){
  set.seed(42)
  seu <- ScaleData(seu, verbose=FALSE)
  seu <- RunPCA(seu, npcs=30, verbose=FALSE)
  seu <- RunUMAP(seu, reduction = "pca", dims = 1:10, verbose=FALSE)
  seu <- FindNeighbors(seu, reduction = "pca", dims = 1:10, verbose=FALSE)
  seu <- FindClusters(seu, resolution = 0.5, verbose=FALSE)
  return(seu)}
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merging Datasets

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merging Datasets

---
"    
  )
  
}

```

## An advanced scRNAseq workflow

![](./imgs/overview3.png)

[overview](./imgs/scRNA_workflow_ver001_20231017.png)

---
## Merge multiple datasets
We will discuss a number of approaches and methods we may need to use to merge datasets.

- No corrections
- Reciprocal Principle Component Analysis (rPCA)
- Harmony

---
## Example dataset

We will be using a dataset containing 4 snRNAseq samples. This is from a [preprint](https://www.biorxiv.org/content/10.1101/2024.12.31.630881v3) studying Alzheimers disease. Though this dataset has 10 samples, we will be using 4 for our example. There are 2 AD samples and 2 Control samples from the entorhinal cortex taht have been collected post-mortem.

You could access the raw data from [GE0: GSE287652](https://www.ncbi.nlm.nih.gov/gds/?term=GSE287652). But we have it here already loaded into a Seurat object and after some preprocessing. 

```{R}
my_seu_list <- readRDS("data/to_integrate.rds")

```

---
## Example dataset

Each dataset has been individually processed, QC'd and reviewed prior to combining into a list. Sotring everything in a list will make our life easier later. 

1) Load into Seurat object. 
2) Log Normalized and scaled. 
3) Filtered based on MT levels (2.5%).
4) Filtered based on doublets (Scrublet).  
5) Regressed to MT. 
6) PCA. 
7) Clusters. 
8) UMAP. 

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Simple Merge

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Simple Merge

---
"    
  )
  
}

```

## Concatenate the datasets

We can use *merge()* function to integrate multiple data sets, as they are. We need to provide a single seurat object as our first argument, and a list containing the rest of our Seurat objects as the second. We also need to provide *Group* information and a *name* for the project as arguments. 


```{r mergeData_woCor_merged,include=TRUE,eval=T}

seu_merge <- merge(my_seu_list[[1]], my_seu_list[2:4],
                            add.cell.ids = c("AD2b", "AD4", "C1", "C3"), project = "Merge")
head(seu_merge,4)

```

---
## Process and make clusters

Now that our data is merged we need to reprocess it. This ensures nromalization and scaling is done in a globally context. We can use our processing and clustering functions to analyse our merged dataset. 

```{r sec3_mergeData_woCorr_cluster,include=TRUE}
seu_merge <- data_proc(seu_merge)
seu_merge <- quick_clust(seu_merge)
```

---
## UMAP

Our UMAP shows our cells are quite similar. Bu there are a few regions that are distinct depending on the condition. 

```{r}
DimPlot(seu_merge, group.by = "sample_id", pt.size = 0.2)



```


---
## Our samples don't group

* This result indicates there is a difference between our 4 samples groups.
* Is this a true biological phenomena or is it a batch effect?

---
## Our samples don't group


![](./imgs/merge.gif)
[(Slowikowski, 2019)](https://github.com/slowkow/harmonypy)


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merge with reciprocal PCA

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merge with reciprocal PCA

---
"    
  )
  
}

```

## Merge with reciprocal PCA

Reciprocal PCA minimizes the batch effects while merging different data sets.

The steps involved in rPCA:

* Each dataset’s PCA embeddings are reciprocally projected onto the other dataset’s principal components.
* Then nearest neighbors are found mutually across datasets.
* These nearest neighbors serve as anchors, which are used to align datasets.

---
## Merge with reciprocal PCA

![](./imgs/rpca_1.png)

[(Stuart et al, 2019)](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8)

---
## Merge with reciprocal PCA

![](./imgs/rpca_2.png)

[(Stuart et al, 2019)](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8)

---
## RPCA workflow

  1. Normalize data sets. We can use our *data_proc()*. 
  2. Select features for integration by using *SelectIntegrationFeatures()*.
  3. Scale data and process PCA by using the features identified for integration
  4. Identify Anchors for integration by using *FindIntegrationAnchors()*
  5. Integrate data by using *IntegratedData()*
  6. Process *quick_cluster()* and evaluate results with UMAP

---
## Prepare for RPCA merge

First we need to identify features for integration. We do this on our list of Seurat objects. This is similar to the VariableFeatures function we ran on a single dataset, but works across all 4 datasets. We will then run scaling and PCA, using these features.

```{r sec3_mergeData_RPCA_prep,include=TRUE,eval=T}



feats <- SelectIntegrationFeatures(my_seu_list)

my_seu_list_rpca <- lapply(my_seu_list, function(seu, feats){
  seu <- ScaleData(seu, features=feats, verbose=FALSE)
  seu <- RunPCA(seu, features=feats, verbose=FALSE)
  return(seu)}, feats)
```

---
## Integrating data in RPCA merge

We can then identify anchors. These are the features through which we will integrate our data. Once we have these features, we can then integrate our data sets together.

```{r sec3_mergeData_RPCA_int,include=TRUE,eval=T}
anchors <- FindIntegrationAnchors(my_seu_list_rpca, anchor.features = feats, reduction = "rpca")

my_seu_merge_rpca <- IntegrateData(anchorset = anchors)

my_seu_merge_rpca
```


---
## Evaluating RPCA using clusters

To evaluate how well the merge has worked we must check the clustering. Again we must scale, and then use our *quick_clust* function. 

```{r sec3_mergeData_RPCA_cluster,include=TRUE,eval=T}

my_seu_merge_rpca <- ScaleData(my_seu_merge_rpca)
my_seu_merge_rpca <- quick_clust(my_seu_merge_rpca)
```

---
## Assesing Integration

To assess the integration we can use similar metrics to assessing the QC of the datasets in general. 

- Are there discrete clusters?
- Are there distinct markers (and do they make sense)?

We also check the overlap of our datasets. Generally we expect most cells between samples to overlap, butt this can be very experiment dependent. 

---
## Evaluating RPCA using clusters

We can see that our data sets overlay with each other. It looks slightly better than before. The dataset looked pretty good before, but now the overlap is tighter.

```{R}
DimPlot(my_seu_merge_rpca, group.by = "sample_id", pt.size = 0.2)

```

---
## UMAP - Clusters

Our UMAP shows our cell clusters are fairly distinct, though not perfect (and the clustering itself could do with some optimization). 

```{r}
DimPlot(my_seu_merge_rpca, group.by = "seurat_clusters", pt.size = 0.2)

```

---
## Heatmap - clusters

We can check the numbers in each cluster. Broadly, there are similar numbers per cluster now. To do this we make a heatmap and then scale it along the row to accunt for the different number of cells in each sample.  

```{R}
library(pheatmap)
tbl <- table(my_seu_merge_rpca$sample_id, my_seu_merge_rpca$seurat_clusters)
pheatmap(tbl, scale="row")
```


---
## UMAP - Markers

A given cell type should often be clustered together. This means marker genes should be specific. This oligodendrocyte marker has quite specific distribution.

```{r}
FeaturePlot(my_seu_merge_rpca, "MOBP", pt.size = 0.2)

```

---
## UMAP - Annotation

This dataset also has some annotation in the *paper_annot* slot. We can check the distribution of the labels. Our UMAP shows our cell types are distinct.

```{r}
DimPlot(my_seu_merge_rpca, group.by = "paper_annot", pt.size = 0.2)

```

---
## Evaluating RPCA using cell types

Using heatmaps we can also check how specific each cluster is to each cell type.

```{R}
library(pheatmap)

tbl <- table(my_seu_merge_rpca$seurat_clusters, my_seu_merge_rpca$paper_annot)
pheatmap(tbl, scale = "row")

```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Merge data with Harmony

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Merge data with Harmony

---
"    
  )
  
}

```


## Harmony
- Harmony is an R package for single-cell data integration [liike](https://www.nature.com/articles/s41592-019-0619-0).
- There is also a python implementation of this [package](https://github.com/slowkow/harmonypy). 
- Harmony works well with Seurat objects to directly so we can easily add it into our workflow. 

---
## Harmony

Harmony works in a different way to rPCA. 

1) Fuzzy clustering - It will assign clusters, but allow cells to belong to multiple clusters, and caluclate the strength of assingmetn to each cluster. 

2) During clustering there is a penalty term, to maintain diversity of groups i.e. a cluster with just one sample is penalized. This means any structure due to a batch effect is not hard. 

3) The centroid of each cluster is calculated for all cells and each individual sample, then a correction factor for each sample based on these centroids. 

4) Cells are then moved based on the dataset correction factor, weighted by their individual assignment scores for each clsuter

5) Repeat iteratviely until convergence. 

---
## Harmony

![](./imgs/harmony.png)


[(Korsunksy et al, 2020)](https://pmc.ncbi.nlm.nih.gov/articles/PMC6884693/)

---
## Prepare data for Harmony
We can prepare for Harmony in much the same way as we prepare for the simple Seurat merge: merge, normalize, scale, PCA and UMAP.

```{r sec3_mergedata_Harmony_samplePrep,include=TRUE,eval=T}

seu_merge <- merge(my_seu_list[[1]], my_seu_list[2:4],
                            add.cell.ids = c( "C1", "C3","AD2b", "AD4"), project = "Merge")
seu_merge <- data_proc(seu_merge)
seu_merge <- ScaleData(seu_merge)
seu_merge <- RunPCA(seu_merge)
seu_merge <- RunUMAP(seu_merge, reduction = "pca", dims = 1:10, reduction.name = "umap")
```

---
## Prepare data for Harmony

As you can see we are back with our completely separate groups. 

```{r}
DimPlot(seu_merge, group.by = "sample_id")
```

---
## Merge data with Harmony

We can use the *RunHarmony()* function to implement the Harmony correction. 

```{r sec3_mergedata_Harmony_merge,include=TRUE,eval=T}
library(harmony)
seu_merge_harmony <- RunHarmony(seu_merge, group.by.vars= "sample_id", assay.use= "RNA")
seu_merge_harmony <- RunUMAP(seu_merge_harmony, reduction = "harmony", dims = 1:10, reduction.name = "umap_harmony")
seu_merge_harmony <- FindNeighbors(seu_merge_harmony, reduction = "harmony")
seu_merge_harmony <- FindClusters(seu_merge_harmony) 
    

```

---
## Evaluating Harmony using clusters

We can see that our data sets overlay with each other. Again, it looks slightly better than before. The dataset looked pretty good before, but now the overlap is tighter.

```{R}
DimPlot(seu_merge_harmony, group.by = "sample_id", reduction = "umap_harmony", pt.size = 0.2)

```

---
## UMAP - Clusters

Our UMAP shows our cell clusters are fairly distinct, though not perfect (and the clustering itself could do with some optimization). 

```{r}
DimPlot(seu_merge_harmony, group.by = "seurat_clusters", reduction = "umap_harmony",  pt.size = 0.2)

```

---
## Heatmap - clusters

We can check the numbers in each cluster. Broadly, there are similar numbers per cluster now. To do this we make a heatmap and then scale it along the row to account for the different number of cells in each sample.  

```{R}
library(pheatmap)
tbl <- table(seu_merge_harmony$sample_id, seu_merge_harmony$seurat_clusters)
pheatmap(tbl, scale="row")
```

---
## UMAP - Markers

A given cell type should often be clustered together. This means marker genes should be specific. This oligodendrocyte marker has quite specific distribution.

```{r}
FeaturePlot(seu_merge_harmony, "MOBP", pt.size = 0.2)

```

---
## UMAP - Annotation

This dataset also has some annotation in the *paper_annot* slot. We can check the distribution of the labels. Our UMAP shows our cell types are distinct.

```{r}
DimPlot(seu_merge_harmony, group.by = "paper_annot", pt.size = 0.2)

```

---
## Evaluating RPCA using cell types

Using heatmaps we can also check how specific each cluster is to each cell type.

```{R}

tbl <- table(seu_merge_harmony$seurat_clusters, seu_merge_harmony$paper_annot)
pheatmap(tbl, scale = "row")

```

```{R, echo=F, eval=F}

saveRDS(my_seu_merge_rpca,"~/Desktop/integrated.rds" )
saveRDS(my_seu_merge_rpca, "scRNASeq/inst/extdata/data/integrated.rds")

```

---
## Comparing our results


Broadly it seems like rPCA may be the best option in this case. Why?:

1) The integration in general is subtle and rPCA is more conservative
2) Sample UMAP looks cleanest
3) The number of cells per cluster seems more equal
4) The annotation seems cleaner

---
## Compare

.pull-left[
```{R, echo=F}
DimPlot(my_seu_merge_rpca, group.by = "sample_id") + ggtitle("rPCA")

```
  ]
  
.pull-right[
```{R, echo=F}
DimPlot(seu_merge_harmony, group.by = "sample_id", reduction="umap_harmony") + ggtitle("harmony")
```
  ]

---
## Compare

.pull-left[
```{R, echo=F}
tbl <- table(my_seu_merge_rpca$seurat_clusters, my_seu_merge_rpca$paper_annot)
pheatmap(tbl, scale = "row", main="rPCA", treeheight_row = 0, , treeheight_col = 0)
```
  ]
  
.pull-right[
```{R, echo=F}
tbl <- table(seu_merge_harmony$seurat_clusters, seu_merge_harmony$paper_annot)
pheatmap(tbl, main="Harmony", treeheight_row = 0, , treeheight_col = 0)
```
  ]
  
---
## Compare

.pull-left[
```{R, echo=F}
  tbl <- table(my_seu_merge_rpca$sample_id, my_seu_merge_rpca$seurat_clusters)
pheatmap(tbl, scale = "row", main="rPCA", treeheight_row = 0, , treeheight_col = 0)

```
  ]
  
.pull-right[
```{R, echo=F}
tbl <- table(seu_merge_harmony$sample_id, seu_merge_harmony$seurat_clusters)
pheatmap(tbl, scale = "row", main="Harmony", treeheight_row = 0, , treeheight_col = 0)
```
  ]

---
## Data Integration Compared

- Harmony 
 * Works at the cluster level
 * Iterative nature pushes to convergence so can be a heavy handed
 * Allows for more complex model terms for batch correction
 * Fast and scalable

- rPCA 
  * Working at the single cell level
  * Preserves biological structure, by being More lenient and allowing unique groups

---
## Data Integration Compared

Though Harmony and rPCA are our main workhorses for integration. There are many other alternatives too.  

* MNN - Like rPCA it uses MNN across datasets and corrects batch effects while preserving structure (we have code for this in prior version of [course](https://github.com/RockefellerUniversity/SingleCell_Bootcamp/releases/tag/v1.0))
* Liger - Factorizes gene expression into shared and dataset-specific components, so very god at maintaining dataset specific patterns, but it will need some tuning.
* Scanorama	-	Also uses a MNN based approach.	Good for datasets with little overlap, but it is computationally expensive.
* ComBat (from sva package)	Batch Correction - Uses a more traditional linear modeling approach that has been adapted from bulk methods. Good for systematic differences, but less nuanced and tendency to over correct. 
* BBKNN (Batch-Balanced kNN) - Works on neighbor graphs, not counts/PCA. Simple, fast, good for clustering and visual, but there's no depper integration/correction of data.
* scVI (Single-cell Variational Inference) - Uses a deep generative model (VAE) to learn a representation without batch effects. Powerful, scalable, handles missing data	but requires GPU for efficiency.

For more systematic comparison check out this [paper](https://pmc.ncbi.nlm.nih.gov/articles/PMC9982060/).

---
## An advanced scRNAseq workflow

![](./imgs/overview3.png)
[overview](./imgs/scRNA_workflow_ver001_20231017.png)


```{r, echo=F, warning=FALSE, message=F}

rm(seu_merge_harmony, my_seu_list_rpca,my_seu_list,seu_merge)
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Cell type annotation

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Cell type annotation

---
"    
  )
  
}

```

## Manual Annotation

As mentioned before this dataset has been manually annotated. 

```{r}

DimPlot(my_seu_merge_rpca, group.by = "paper_annot")
```

---
## Manual Annotation

This was done by careful assessment of the marker genes. Here we are look at Oligodendrocyte markers. 

```{r}

FeaturePlot(my_seu_merge_rpca, c("MOBP","MAG"))
```


## Automated annotation

To annotate the Single-cell data sets, we can evaluate the gene expression pattern of well known cell-type specific marker genes and make a manual annotation. This is time consuming and not systematic.

Here, we will introduce two more strategies to make cell type annotations automatically:
  1. Mapping and annotating query datasets with Seurat using a reference data set.  [link](https://satijalab.org/seurat/articles/integration_mapping.html)
  2. Make annotation with SingleR [link](https://bioconductor.org/packages/release/bioc/html/SingleR.html)

---
## Cell type annotation

For this we need a reference dataset and a query dataset. Our annotation ends up being only as good as our reference dataset. There are many sources for reference data. 

* R packages:
  - [celldex](https://bioconductor.org/packages/release/data/experiment/html/celldex.html)
  - [ExperimentHub](https://www.bioconductor.org/packages/release/bioc/html/ExperimentHub.html)
  
* Consortium data i.e. [Allen Brain Map](https://portal.brain-map.org)
* Papers (though this can be variable) - [Adipose](https://gitlab.com/rosen-lab/white-adipose-atlas) or [Neuronal](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE287652)

Depending on the format of the data, you may be set to go straightaway, need to do some light processing, or reanalyze the whole thing. 


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Annotation with SingleR

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Annotation with SingleR

---
"    
  )
  
}

```


## Annotation with SingleR

[SingleR](https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html) is Bioconductor package which can be used to predict annotations of a single-cell dataset. It is maybe the most flexible way of annotating your data, as it will accept a variety of kinds of reference data including bulk and scRNAseq experiments. 
SingleR works with a very simple method: calculate a spearman rank correlation between reference and test dataset for each label.

Despite this simplicity, there is also scope to do more complex annotation with some advacned features i.e. to improve resolution of related labels or using multiple references. You can dig into this further in the [singleR book](https://bioconductor.org/books/release/SingleRBook/).

---
## Annotation with SingleR

Lets start out by using the [Human Primary Cell Atlas](https://bmcgenomics.biomedcentral.com/articles/10.1186/1471-2164-14-632). This is a collection of microarray datasets from human primary cells that have been aggregated together. To access this data we will use the *celldex* package. 

```{R}
library(celldex)
hpcad <- HumanPrimaryCellAtlasData()

```

---
## Annotation with SingleR

In this case the data is stored as a SummarizedExpriment; a specialized Bioconductor format designed for holding data matrices and their metadata. The reference data for SingleR can either be in this format or as a SingleCellExpriment (another Bioconductor format specific to single cell analysis). 

```{R}
hpcad 

```

---
## Annotation with SingleR

At the moment our *test* data is a Seurat object which is not Bioconductor friendly. 

```{R}
my_seu_merge_rpca

```

We can simply extract out a data matrix containing count information. This is good for SingleR. 

```{r}
my_seu_merge_rpca_mat <- GetAssayData(my_seu_merge_rpca)

my_seu_merge_rpca_mat[1:5,1:5]
```

---
## Annotation with SingleR

We are almost ready to run SingleR. We have our test and reference data. The last part we need is labels. This can just be a vector containing all the labels. We can grab this easily from our reference dataset. We can see there are several options here. Let's just stick to *label.main*.

```{r}
colData(hpcad)

```


```{R}
library(SingleR)

pred_res <- SingleR(ref = hpcad, test = my_seu_merge_rpca_mat, labels = hpcad$label.main)

```

The score is generated comparing the expression levels of a cell in query dataset and the expression pattern of certain group (eg. cell types) in reference dataset. A cell would be assigned as the cell type which has highest score

```{r}
head(pred_res,2)
```


---
## Annotation with SingleR
By converting to a matrix, we can check the cell type scoring using a heatmap. 

```{r}
mat <- as.matrix(pred_res$scores)
rownames(mat) <- rownames(pred_res)
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE, fontsize_col = 5)
```

---
## Annotation with SingleR

We can now add our labels back to our original Seurat object by a quick assignment. This then allows us to start reviewing the annotation in the context of UMAPs and also versus our other annotation. 

```{r}
my_seu_merge_rpca$hpcad_singleR_labels <- pred_res$labels

summ_table <- table(my_seu_merge_rpca$hpcad_singleR_labels, my_seu_merge_rpca$paper_annot)

pheatmap(summ_table, scale="column", fontsize_row = 5)
```

---
## Annotation with SingleR

```{r}
DimPlot(my_seu_merge_rpca, group.by = "hpcad_singleR_labels")

```

---
## Annotation with SingleR

Lets try an alternative dataset. Often we will have data from other Seurat objects that we want to use as a reference. Here we have a processed version of human data from the [Allen Brain Map](https://portal.brain-map.org/atlases-and-data/rnaseq). This is 10X data from 2020. 

```{r, eval=F}
abm <- readRDS("data/abm.rds")

```

---
## Annotation with SingleR

There are several interesting labels associated with this data. Lets focus on the *class_label*.

```{r, eval=F,echo=TRUE}
head(abm)

```

```{r, echo=F}
out<-read.csv("data/out.txt", row.names=1)
out
```

---
## Annotation with SingleR

As our reference data is in a Seurat format we can just extract out the data matrix of counts. We also already have our matrix from our test data. 

```{R, eval=F, echo=T}

pred_res2 <- SingleR(ref = GetAssayData(abm), test = my_seu_merge_rpca_mat, labels = abm$class_label)
```

```{R, eval=F, echo=F}
saveRDS(pred_res2,file = "data/annotate_df1.rds")
```

```{R, eval=T, echo=F}
pred_res2 <- readRDS(file = "data/annotate_df1.rds")
my_seu_merge_rpca <- readRDS(file = "data/annotated.rds")
```

```{r}
head(pred_res2,2)
```

---
## Annotation with SingleR

By converting to a matrix, we can check the cell type scoring using a heatmap. 

```{r}
mat <- as.matrix(pred_res2$scores)
rownames(mat) <- rownames(pred_res2)
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE, fontsize_col = 5)
```

---
## Annotation with SingleR

We can now add our labels back to our original Seurat object by a quick assignment. This then allows us to start reviewing the annotation in the context of UMAPs and also versus our other annotation. 

```{r, eval=F}

my_seu_merge_rpca$abm_singleR_labels <- pred_res2$labels
```

```{r}
summ_table <- table(my_seu_merge_rpca$abm_singleR_labels, my_seu_merge_rpca$paper_annot)

pheatmap(summ_table, scale="column", fontsize_row = 5)
```

---
## Annotation with SingleR

```{r}
DimPlot(my_seu_merge_rpca, group.by = "abm_singleR_labels")

```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Annotation with Seurat

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Annotation with Seurat

---
"    
  )
  
}

```

---
## Anotation with Seurat
  
Seurat uses a similar appraoch to integration to be able to fnid anchors between datasets. It can then use this to transfer label information from a reference to a test dataset.

A restriction of this approach is both datasets have to be Seurat objects and therefore single cell datasets. We will use the Allen Brain Map again for this analysis. 

---
## Reference and query datasets
  
As with integration, we find integration features in common, then scale and run PCA in the context of these specific features. 

```{r sec3_ctAnno_Seurat_gatherData,include=TRUE,eval=F}

transfer_list <- list("ref"=abm,"query"=my_seu_merge_rpca)
feats <- SelectIntegrationFeatures(transfer_list)

transfer_list <- lapply(transfer_list,function(seu,feats){
  seu <- ScaleData(seu,features=feats,verbose=FALSE)
  seu <- RunPCA(seu,features=feats,verbose=FALSE)
  return(seu)}, feats)

```

---
## Predict cell types for query
  
Identify the anchors between reference and query data sets, using *FindTransferAnchors()*. These are essential to transfer information from our reference to our query. We can then transfer the cell type information. For each cell in query dataset, the score for each given cell type was estimated by the gene expression pattern of anchor genes using the *TransferData()* function. 

```{r sec3_ctAnno_Seurat_tranferAnno,include=TRUE,eval=F}
anchors <- FindTransferAnchors(reference = transfer_list$ref,
                               query=transfer_list$query,
                               dims=1:30, reference.reduction="pca")
pred_res3 <- TransferData(anchorset = anchors, refdata=transfer_list$ref$class_label)
```

```{R, eval=F, echo=F}
saveRDS(pred_res3,file = "data/annotate_df2.rds")
```

```{R, eval=T, echo=F}
pred_res3 <- readRDS(file = "data/annotate_df2.rds")

```

```{r}
head(pred_res3,2)
```

---
## Predict cell types for query
The cell type with highest score was assigned to the given cell. We can visualize this score with a heatmap. 

```{r}
mat <- as.matrix(pred_res3[,-c(1,5)])
colnames(mat) <- gsub("prediction.score.","",colnames(mat))
pheatmap(mat,scale = "row",show_rownames = FALSE)
```


--
## Annotation with SingleR
  
We can now add our labels back to our original Seurat object by a quick assignment. This then allows us to start reviewing the annotation in the context of UMAPs and also versus our other annotation. 

```{r, eval=F}

my_seu_merge_rpca$abm_seurat_labels <- pred_res3$predicted.id

```

```{R}

summ_table <- table(my_seu_merge_rpca$abm_seurat_labels, my_seu_merge_rpca$paper_annot)

pheatmap(summ_table, scale="column", fontsize_row = 5)
```

---
## Annotation with SingleR
  
```{r}
DimPlot(my_seu_merge_rpca, group.by = "abm_seurat_labels")

```


---
## Seurat vs SingleR annotation
  
  Next we can compare our two annotations:
  
```{R}

table(my_seu_merge_rpca$abm_seurat_labels == my_seu_merge_rpca$abm_singleR_labels)
tbl <- table(my_seu_merge_rpca$abm_seurat_labels,my_seu_merge_rpca$abm_singleR_labels)
pheatmap::pheatmap(tbl,scale = "row")
```

---
## Seurat vs SingleR annotation
  
  The results are similar but there is a clear difference in the identification of the OPC group. These are Oligodendrocyte precursor cells, and are considered non-neural.

In this case it seems that Seurat has done a better job. But maybe with a different reference, or with the more specific group labels SingleR may perform better. 

---
  ## Seurat vs SingleR annotation
  
  This isn't always the case. As a general rule we find:

* Seurat: Wins on speed
* SingleR: More reliable and consistent

---
## LLM annotation

There have also been some interesting efforts to use LLMs or Deep Learning to annotate cells, either with specialized models or generic models like [ChatGPT](https://www.nature.com/articles/s41592-024-02235-4).

We have not exhaustively tested these, but the consensus is that they provide a good quick estimate, especially when you do not have a reliable reference dataset. 

Often domain specific knowledge and good reference datasets will outperform the more general LLM approaches. 



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Differential Gene Expression

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
  "    
  )
}else{
  cat("# Differential Gene Expression

---
  "    
  )
  
}

```

# Differential Gene Expression



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Differential Cell Counts

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 
  
  ---
  "    
  )
}else{
  cat("# Differential Cell Counts

---
  "    
  )
  
}

```  


# Differential Cell Counts



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# CITE-Seq 

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 
  
  ---
  "    
  )
}else{
  cat("# CITE-Seq 

---
  "    
  )
  
}

```

## CITE-Seq

The CITE-Seq method labels different types of cells or different samples with hashtag-labeled antibodies. Then, the cells can be pooled together into a single library and for sequencing at the same time. After sequencing, the cells can be separated by the different antibody hashtags.

- Here, we will use a dataset from Seurat vignette [link](https://satijalab.org/seurat/articles/hashing_vignette.html)

---
## Load data

```{r sec3_CITE_prep,include=TRUE,eval=T}

rna.mat <- readRDS("data/pbmc_umi_mtx.rds")
dim(rna.mat)

hto.mat <- readRDS("data/pbmc_hto_mtx.rds")
dim(hto.mat)
rownames(hto.mat)
```


---
## Prepare data

```{r}
seu_obj <- CreateSeuratObject(counts=rna.mat,project="citeSeq_demo")
seu_obj[["HTO"]] <- CreateAssayObject(counts=hto.mat)
seu_obj
```

```{r, echo=F, eval=T, warning=F, message=FALSE, include=F}

rm(hto.mat, rna.mat )
gc()
```

---
## Cluster with regular workflow
```{r sec3_CITE_clust,include=TRUE,eval=T}

DefaultAssay(seu_obj) <- "RNA"
seu_obj <- data_proc(seu_obj)
seu_obj <- ScaleData(seu_obj)
```

---
## Cluster with regular workflow

```{R}
seu_obj <- quick_clust(seu_obj)
DimPlot(seu_obj,group.by = "seurat_clusters",pt.size = 0.2,label = TRUE)+NoLegend()
```


---
## Centered log-ratio transformation

* Hashtag counts are a kind of [compositional data](https://en.wikipedia.org/wiki/Compositional_data), which define the proportion of hashtags in each cell barcode.
* CLR is a method to process compositional data. It is a log-ratio transformation that centers the data around the geometric mean of each cell barcode.

```{r sec3_CITE_hto,include=TRUE,eval=T}
DefaultAssay(seu_obj) <- "HTO"
seu_obj <- NormalizeData(seu_obj, assay="HTO", normalization.method="CLR")

```

---
## Differentiate Hashtags

- Demultiplex HTOs with *HTODemux()*
- Threshold for positive call: *0.99 quantile*

```{r}
seu_obj <- HTODemux(seu_obj, assay = "HTO", positive.quantile = 0.99)

head(seu_obj,2)
```

---
## Decide postive hashtags

* Use the "negative" distribution to calculate cut-off value (99% quantile).
* Every cell barcode with HTO-A >= cut-off was assigned as HTO-A positive.

```{r CITESeq_posEG,include=TRUE,eval=TRUE,dpi=300}
# Distribution of HTO-A level
RidgePlot(seu_obj,features = "HTO-A",group.by = "orig.ident")+NoLegend()
```

---
## Demutiplex result

* The demultiplex results are in the column *HTO_classification.global* and *hash.ID*
* In the HTO_classification.global:
  + The *Singlet* means the cell barcode with only one particular hashtag. It can be applied to further analysis.
  + The *Negative* means no hashtags passed cut-off in the cell barcodes.
  + The *Doublet* means multiple hashtags passed cut-off in the cell bacodes.
    + The Doublets here didn't mean multiple cells in a single droplet.
* In the column hash.ID, particular hashtag for each cell barcode assigned in the column *hash.ID*. The *Negative* or *Doublet* were the same as in the column *HTO_classification.global*.

---
## Demutiplex result

```{r CITESeq_posEG2,include=TRUE,eval=TRUE,dpi=300}
RidgePlot(seu_obj,
          features = c("HTO-A","HTO-B"),
          group.by = "hash.ID")+NoLegend()
#
table(seu_obj$HTO_classification.global)
#
table(seu_obj$hash.ID)
#
table(seu_obj$HTO_classification.global,seu_obj$hash.ID)
```

---
## UMAP ~ split by Hashtags

```{r CITESeq_spltUMAP,include=TRUE,eval=TRUE,dpi=300}
DimPlot(seu_obj,group.by = "seurat_clusters",label = TRUE,pt.size = 0.2,split.by = "hash.ID",ncol = 5)+NoLegend()
```

---
## Unassigned cells

* The cell barcodes with *Negative or Doublet* would not be used for further analysis directly.
  + Generally, the mis-labeled rate in CITE-Seq would be ranged from 10% ~ 80% (avg 30%).
  + If you use hashtag to label cell types, we could try to rescue the mis-labeled cells by using the clustering in UMAP. [assume a given cell type shall group together]
  + If you use hashtags to label samples, it would be safer to exclude these cells for following analysis.
  

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Review

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 
  
  ---
  "    
  )
}else{
  cat("# Review

---
  "    
  )
  
}

```


![overview](./imgs/scRNA_workflow_ver001_20231017.png)

---
## Resources

- [10X Single cell software](https://support.10xgenomics.com/single-cell-gene-expression/software/overview/welcome)
- [Cell Ranger Download](https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest)
- [Interpreting Web Summaries](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/summary)
- [Single Cell Tools](https://github.com/seandavi/awesome-single-cell)



  

