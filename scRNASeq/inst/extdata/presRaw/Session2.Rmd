---
title: "Single-cell RNA sequencing ~ Session 2 <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "https://rockefelleruniversity.github.io/scRNA-seq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---
```{r setup, include=FALSE}
suppressPackageStartupMessages(require(knitr))
suppressPackageStartupMessages(require(Seurat))
suppressPackageStartupMessages(require(dplyr))
suppressPackageStartupMessages(require(bioMart))
suppressPackageStartupMessages(require(SeuratWrappers))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```

##  Data analysis with [Seurat](https://satijalab.org/seurat/)

[Seurat](https://satijalab.org/seurat/) is a powerful package for single-cell data analysis. It supports many common analysis of single-cell RNAseq and cross connection with many useful packages through [SeuratWrapper](https://github.com/satijalab/seurat-wrappers). 

In this session, we will demonstrate our regular workflow for single-cell RNAseq data analysis with Seurat.


```{r load_pack,include=TRUE,eval=FALSE}
library(Seurat)
library(ggplot2)
library(scran)
library(scuttle)
library(reticulate)
```

# Introduction

## Outlines
- Load data into Seurat
- Data normalization
- Calculate mitochondrial contains
- Estimate cell cycle phases
- Evaluate Doublets with scrublet
- QC plots
- Dimension reduction
- Clustering
- Evaluate results ~ cell type specific clusters
- Identify marker genes by clusters
- Transfer UMAP and annotation from Seurat to LOUPE 

## Seurat
* An R toolkit for single cell genomics [link](https://satijalab.org/seurat/index.html)
* The workflow we used in this section was based on Seurat vignette [link](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html).
* References
  + **Seurat V4**, Hao, Hao et al., *Cell* (2021) [link](https://doi.org/10.1016/j.cell.2021.04.048)
  + **Seurat V3**, Stuart, Butler et al., *Cell* (2019) [link](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8)
  + **Seurat V2**, Butler, et al., *Nat Biotechnol* (2018) [link](https://doi.org/10.1038/nbt.4096)
  + **Seurat V1**, Satija, Farrell, et al., *Nat Biotechnol* (2015) [link](https://doi.org/10.1038/nbt.3192)
* Demo data used in this section was the **10k Human PBMC data** from *10X Genomics* [link](https://www.10xgenomics.com/resources/datasets/10k-human-pbmcs-3-v3-1-chromium-controller-3-1-high).

## What is this data?

Matrix download, and what other files needed?

```{r}
download.file("https://cf.10xgenomics.com/samples/cell-exp/6.1.0/10k_PBMC_3p_nextgem_Chromium_Controller/10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz","10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz")

untar("10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz")

```



## Load Cellranger data into R

## Load cellranger matrix into matrix

```{r,include=F,echo=F,eval=FALSE}
mtx_dir <- "filtered_feature_bc_matrix"

#/10k_PBMC_3p_nextgem_Chromium_Controller_filtered_feature_bc_matrix.tar.gz"
```

```{r load_data,include=TRUE,eval=FALSE}
library(Seurat)
#
mtx <- Seurat::Read10X(mtx_dir)
#
is(mtx)
head(mtx)
```

## Load cellranger matrix (in .h5 format) into matrix
- In an alternative way, we can use *Read10X_h5* function to read cellranger matrix from an **.h5** file.
- What is difference? Why would do it differently?


```{r load_h5,include=TRUE,eval=FALSE}
h5_file <- "path to matrix h5 file"
h5_file <- "~/Downloads/10k_PBMC_3p_nextgem_Chromium_Controller_molecule_info.h5"
mtx <- Seurat::Read10X_h5(h5_file)
#
mtx
```

## Create Seurat object from matrix - defaults for this are 0? Why different? Should include?
* The matrix is loaded into Seurat object with **CreateSeurtObject()**
* Cut-off
  + min_gene: minimal genes detected in each cell. *(cells with too few genes detected)*
  + min_cell: minimal cells a given gene was tested positive. *(Remove genes expressed in too few cells)*
```{r load_CreateOBJ,include=TRUE,eval=FALSE}
sample_id <- "PBMC_10k" # sample name
min_gene <- 200 # cut-off for cells with too few genes detected
min_cell <- 10 # cut-off to remove genes expressed in too few cells
#
seu_obj <- Seurat::CreateSeuratObject(mtx,project=sample_id,min.cells=min_cell,min.features=min_gene)
seu_obj[["dset"]] <- sample_id # Create a category for sample
seu_obj <- Seurat::RenameCells(seu_obj,add.cell.id=sample_id) # add sample name in front of cell barcode
```

```{r laod_CreatOBJ_pres,include=TRUE,eval=TRUE}
message("Seurat Object")
seu_obj
#
message("Metadata information")
head(seu_obj,2)
```

## Estimate proportions of mitochondrial genes - what is bad proporiotn?

* Estimate the counts of mitochondrial genes in overall counts with **PercentageFeatureSet()**
* The Feature sets can be selected by *patterns of gene names* or *directly assign specific genes*. 
  + While assign gene names, we have to make sure *the given genes are detected in the Seurat object*.
```{r load_estMT,include=TRUE,eval=FALSE}
message("select by pattern")
seu_obj[["percent.mt"]] <- PercentageFeatureSet(seu_obj,pattern = "^MT-")
summary(seu_obj$percent.mt)
#
message("assign gene names")
mt_gene <- c("MT-ND1","MT-ND2","MT-ND3","MT-ND4","MT-ND4L","MT-ND5","MT-ND6",
             "MT-CO1","MT-CO2","MT-CO3","MT-ATP6","MT-ATP8","MT-CYB")
mt_gene_det <- mt_gene[mt_gene %in% rownames(seu_obj)] # make sure the genes presented in the seurat object
seu_obj[["percent.mt2"]] <- PercentageFeatureSet(seu_obj,features = mt_gene_det)
summary(seu_obj$percent.mt2)
#
message("Test condordance with Spearman's correlation")
dat <- data.frame(byPattern=seu_obj$percent.mt,byGene=seu_obj$percent.mt2,stringsAsFactors = FALSE)
cor_val <- cor.test(dat$byPattern,dat$byGene,method = "spearman")
ggplot(dat,aes(x=byPattern,y=byGene))+geom_point()+geom_smooth()+
  labs(x="% of MT,est by pattern",y="% of MT, est by genes",
       subtitle = paste0("rho=",round(cor_val$estimate,3),"; p-value=",cor_val$p.value[1]))+
  theme_classic()
```


# Normalization, Feature selection, and data scaling
- Log normalization
- SCTransform

## Log normlaization ~ default 
* In Seurat vignette, this step includes:
  + log normalization with *NomalizeData()*
  + Identify Variable Features with *FindVariableFeatures()*
  + Scale Data with *ScaleData()*
```{r norm_log,include=TRUE,eval=FALSE}
message("log normalization, scale to 10,000")
seu_obj <- NormalizeData(seu_obj,normalization.method="LogNormalize",scale.factor=10000)
#
message("Identify variables, select top 3000 features with VST method")
seu_obj <- FindVariableFeatures(seu_obj,select.method="vst",nfeatures=3000)
#
message("Scale data")
seu_obj <- ScaleData(seu_obj)
```

## Highly Variable Features
- Highly variable features were colored with *red*. 
- Gene symbols of the top 10 higly variable features were labeled near by the spots
```{r norm_plotHVF,include=TRUE,eval=TRUE}
top10 <- head(VariableFeatures(seu_obj), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(seu_obj)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

## Normalization and scaling by usign SCTransform
- SCTransform is a normalization based on negative binomial regression
- It is performed with **SCTransform()** function of Seurat.
- This function equal to the combinations of NormalizaeData(), FindVariableFeatures(), and ScaleData().
- The normalized data is stoered in assay **SCT**.
```{r norm_sct,include=TRUE,eval=FALSE}
seu_obj <- SCTransform(seu_obj,variable.features.n = 3000)
#
seu_obj
```

## Compare the results between log normalization and SCTransform

- pros and cons?
- do we have any plots to describe this?

```{r norm_comp,include=TRUE,eval=FALSE}
message("get log normalization data")
log_mat <- GetAssayData(seu_obj,assay="RNA",slot="data")
log_mat <- as.matrix(log_mat)
log_avgExp <- rowMeans(log_mat)
#
message("get SCTransformed data")
sct_mat <- GetAssayData(seu_obj,assay="SCT",slot="data")
sct_mat <- as.matrix(sct_mat)
sct_avgExp <- rowMeans(sct_mat)
#
message("Test concordance with Spearman's correlation")
dat <- data.frame(logNorm=log_avgExp,SCT=sct_avgExp,stringsAsFactors = FALSE)
cor_val <- cor.test(log_avgExp,sct_avgExp,method = "spearman")
ggplot(dat,aes(x=logNorm,y=SCT))+geom_point()+geom_smooth()+
  labs(x="Log_Normalization",y="SCTransform",subtitle = paste0("rho=",round(cor_val$estimate,3),"; p-value=",cor_val$p.value[1]))+
  theme_classic()
```

# Cell cycle Phases
In this step, we will introduce two methods to estimate cell cycle phase for each cell.
- The CellCycleScoring function in *Seurat*
- Cyclone function in *scran* 

## Estimate with CellCycleScoring function of Seurat
* Requirement
  + The Seurat object after normalization
  + Features for S-Phase (feat_s)
  + Features for G2M-Phase (feat_g2m)
  + Seurat provide features for S/G2M-Phase
```{r ccPhase_Seurat,include=TRUE,eval=FALSE}
message("Features for S-Phase")
feat_s <- cc.genes$s.genes
feat_s
#
message("Features for G2M-Phase")
feat_g2m <- cc.genes$g2m.genes
feat_g2m
```

## Estimate with CellCycleScoring function of Seurat
* Rationale
  + Estimate the scoring based on specific features for S-phase/G2M-phase, respectively
  + Differentiate Phase by the scores.
  + For a given cell with significant high S.Score or G2M.Score was assigned as S/G2M, respectively
  + Cells with low both S.Score and G2M.Score were assigned as G1.
* Would *overestimate* cells in S-/G2M-phases in the tissues with low cell cycle, eg neurons (what does this look like?)
```{r ccPhase_plot_Seurat,include=TRUE,eval=FALSE}
seu_obj <- CellCycleScoring(seu_obj,s.features = feat_s,g2m.features = feat_g2m)
#
dat_s <- data.frame(cell_id=Cells(seu_obj),cat="S_Score",Phase=seu_obj$Phase,score=seu_obj$S.Score,stringsAsFactors = FALSE)
dat_g2m <- data.frame(cell_id=Cells(seu_obj),cat="G2M_Score",Phase=seu_obj$Phase,score=seu_obj$G2M.Score,stringsAsFactors = FALSE)
dat <- rbind(dat_s,dat_g2m)
#
dat$Phase <- factor(dat$Phase,levels = c("G1","S","G2M"))
ggplot(dat,aes(x=Phase,y=score,fill=Phase))+geom_boxplot()+
  labs(x="",y="Score",fill="Phase")+
  facet_wrap(~cat)+theme_classic()
```

MISSING SOME SLIDES HERE.



# Detect doublets with Scrublet

## Description
* Doublets mean multiple cells clumped in the same single droplet. 
+ A doublet may have much more UMIs and Genes in a single cell barcode than the overall population
+ Multiple marker genes, even they are exclusive, can be detected in doublets at the same time. 

* Scrublet is a tool to detect doublets
+ The GitHub [link](https://github.com/swolock/scrublet) 
+ Original Paper on bioRxiv [link](https://www.biorxiv.org/content/10.1101/357368v1)
+ It's based on python. So, we have to use reticulate to invoke scrublet into R.

## Estimate doublet score
```{r}
library(Herper)

conda_install  <- install_CondaTools("scrublet","scRNA",pathToMiniConda = "../mini")

Sys.setenv('RETICULATE_PYTHON'=file.path(conda_install$pathToEnvBin, "python"))
```


```{r det_doublet_est,include=TRUE,eval=FALSE}


message("invoke scrublet in R by using reticulate")
# library(reticulate)
# py_path <- "path to the python with scrublet installed"
# # py_path <- "/Users/JDLuo/opt/anaconda3/envs/reticulate/bin/python"
# Sys.setenv('RETICULATE_PYTHON'=py_path)
scr <- import("scrublet")
#
message("dumping count matrix from seurat object")
mat <- GetAssayData(seu_obj,assay = "RNA",slot = "counts")
mat <- as.matrix(mat)
#
message("Estimate doublet score")
scrub <- scr$Scrublet(t(mat))
doublet <- scrub$scrub_doublets()
names(doublet) <- c("doublet_score","doublet")
#
message("doublet score")
summary(doublet$doublet_score)
#
message("doublets")
table(doublet$doublet)
```
