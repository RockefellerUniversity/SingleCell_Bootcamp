<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Single-cell RNA sequencing ~ Session 3 ¶  ¶ ¶  ¶ </title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <script src="libs/header-attrs-2.22/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Single-cell RNA sequencing ~ Session 3 ¶ <html> ¶ ¶ <hr color='#EB811B' size=1px width=796px> ¶ </html>
]
.author[
### Rockefeller University, Bioinformatics Resource Centre
]
.date[
### <a href="https://rockefelleruniversity.github.io/scRNA-seq/" class="uri">https://rockefelleruniversity.github.io/scRNA-seq/</a>
]

---






## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)

---
# Outlines
- Merge multiple data sets - 4 different approaches for this
- Droplet processing - 3 different approaches for this
- Pseudotime analysis with slingshot
- CITE-seq data processing

---
class: inverse, center, middle

# Merging Datasets

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Merge multiple datasets
We will discuss a number of approaches and methods we may need to use to merge datasets.

- No corrections
- Reciprocal Principle Component Analysis (RPCA)
- Mutual Nearest Neighbors (MNN)
- Harmony


---
## Example dataset

We will be using the IFNB-Stimulated and Control PBMCs from Seurat Data. The easiest way to get this data is from their custom package *SeuratData* which is hosted on GitHub. 

We will quickly show you how to get this data, but it isn't necessary to run these steps. 


```r
devtools::install_github("satijalab/seurat-data")
```


```r
library(Seurat)
library(SeuratData)
InstallData("ifnb")
LoadData("ifnb")
```

```
## An object of class Seurat 
## 14053 features across 13999 samples within 1 assay 
## Active assay: RNA (14053 features, 0 variable features)
```

```r
head(ifnb, 2)
```

```
##                   orig.ident nCount_RNA nFeature_RNA stim seurat_annotations
## AAACATACATTTCC.1 IMMUNE_CTRL       3017          877 CTRL          CD14 Mono
## AAACATACCAGAAA.1 IMMUNE_CTRL       2481          713 CTRL          CD14 Mono
```

---
## Example dataset

This dataset is already loaded in as a Seurat object, and it is already merged. So we need to split it, so we can merge it ourselves! The groups are in the "stim" column of the metadata.


```r
table(ifnb$stim)
ifnb_list &lt;- Seurat::SplitObject(ifnb, split.by = "stim")
ifnb_list
```



---
## Load in your dataset

We have the ifnb_list save in an RData object, which you can load in. 


```r
load("data/seuOBJ_IFNB_splitByStim.RData")
```

---
## Create some functions
We are going to try out a few merging approaches. We want to wrap some of our analysis steps into a function to simplify rerunning things.

Normalization: 
  * Log normalization with scale factor = 10,000
  * Find Variable features with vst, select top 2000 variable features
  

```r
data_proc &lt;- function(seu) {
    seu &lt;- NormalizeData(seu, normalization.method = "LogNormalize", scale.factor = 10000)
    seu &lt;- FindVariableFeatures(seu, select.method = "vst", nfeatures = 2000)
    return(seu)
}
```

---
## Create some functions

Make clusters:
  * Scale data with *ScaleData()*
  * Principle Component Analysis by using *RunPCA()* with npcs=30 PCs
  * Make non-linear dimensional reduction in UMAP by using *RunUMAP()* with dims=1:10
  * Estimate Neighbors by using *FindNeighbors()* with dims=1:10
  * Identify clusters with *FindClusters()* by using resolution=0.5
  

```r
quick_clust &lt;- function(seu) {
    set.seed(1001)
    seu &lt;- ScaleData(seu, verbose = FALSE)
    seu &lt;- RunPCA(seu, npcs = 30, verbose = FALSE)
    seu &lt;- RunUMAP(seu, reduction = "pca", dims = 1:10, verbose = FALSE)
    seu &lt;- FindNeighbors(seu, reduction = "pca", dims = 1:10, verbose = FALSE)
    seu &lt;- FindClusters(seu, resolution = 0.5, verbose = FALSE)
    return(seu)
}
```

---
class: inverse, center, middle

# Simple Merge

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Concatenate the datasets

We can use *merge()* function to integrate our two data sets, as they are. We need to provide Group information and a name for the project as arguments. 


```r
ifnb_merge &lt;- merge(ifnb_list$CTRL, ifnb_list$STIM, add.cell.ids = c("CTRL", "STIM"),
    project = "ifnb_seuMerge")
head(ifnb_merge, 2)
```

```
##                        orig.ident nCount_RNA nFeature_RNA stim
## CTRL_AAACATACATTTCC.1 IMMUNE_CTRL       3017          877 CTRL
## CTRL_AAACATACCAGAAA.1 IMMUNE_CTRL       2481          713 CTRL
##                       seurat_annotations
## CTRL_AAACATACATTTCC.1          CD14 Mono
## CTRL_AAACATACCAGAAA.1          CD14 Mono
```

---
## Process and make clusters
We can use our processing and clustering functions to analyse our merged dataset. 


```r
ifnb_merge &lt;- data_proc(ifnb_merge)
ifnb_merge &lt;- quick_clust(ifnb_merge)
```

---
## UMAP

Our UMAP shows our cells are distinct, depending on the condition. 


```r
DimPlot(ifnb_merge, group.by = "stim", pt.size = 0.2)
```

![](Session3_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---
## Evaluate with cell types
A given cell type should often be clustered together. This pattern indicates the opposite. Different cell types are split into distinct groups depending on the sample.


```r
DimPlot(ifnb_merge, group.by = "seurat_annotations", pt.size = 0.2, split.by = "stim")
```

![](Session3_files/figure-html/sec3_mergeData_woCorr_eval-1.png)&lt;!-- --&gt;

---
## STIM/CTRL don't group

* This result indicates the difference between STIM and CTRL groups is huge.
* Is this a true biological phenomena or is it a batch effect?

---
class: inverse, center, middle

# Merge with reciprocal PCA

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Merge with reciprocal PCA
Reciprocal PCA minimizes the batch effects while merging different data sets.

This workflow is modified from canonical correlation analysis (CCA), which is widely used to merge batches.

---
## RPCA workflow

  1. Normalize data sets. We can use our *data_proc()*. 
  2. Select features for integration by using *SelectIntegrationFeatures()*.
  3. Scale data and process PCA by using the features identified for integration
  4. Identify Anchors for integration by using *FindIntegrationAnchors()*
  5. Integrate data by using *IntegratedData()*
  6. Process *quick_cluster()* and evaluate results with UMAP


---
## Prepare for RPCA merge

First, we prepare the data for integration. We will normalize the data sets separately. Than, we need to identify features for integration. This is similar to the VariableFeatures function we ran on a single dataset. Lastly we run scaling and PCA, using these features.


```r
ifnb_list_rpca &lt;- lapply(ifnb_list, data_proc)

feats &lt;- SelectIntegrationFeatures(ifnb_list_rpca)

ifnb_list &lt;- lapply(ifnb_list, function(seu, feats) {
    seu &lt;- ScaleData(seu, features = feats, verbose = FALSE)
    seu &lt;- RunPCA(seu, features = feats, verbose = FALSE)
    return(seu)
}, feats)
```


---
## Integrating data in RPCA merge

We can then identify anchors. These are the features through which we will integrate our data. Once we have these features, we can then integrate our data sets together.


```r
anchors &lt;- FindIntegrationAnchors(ifnb_list, anchor.features = feats, reduction = "rpca")

ifnb_merge &lt;- IntegrateData(anchorset = anchors)

ifnb_merge
```

```
## An object of class Seurat 
## 16053 features across 13999 samples within 2 assays 
## Active assay: integrated (2000 features, 2000 variable features)
##  1 other assay present: RNA
```



---
## Evaluating RPCA using clusters

To evaluate how well the merge has worked we must check the clustering. Again we must scale, and then use our *quick_clust* function. 

We can now see that our two data sets overlay with each other.


```r
ifnb_merge &lt;- ScaleData(ifnb_merge)

ifnb_merge &lt;- quick_clust(ifnb_merge)

DimPlot(ifnb_merge, group.by = "stim", pt.size = 0.2)
```

---
## Evaluating RPCA using clusters

We can now see that our two data sets overlay with each other.

![](Session3_files/figure-html/sec3_mergeData_RPCA_cluster2-1.png)&lt;!-- --&gt;

---
## Evaluating RPCA using clusters

We can check the numbers in each cluster. Broadly, there are similar numbers per cluster now. 


```r
tbl &lt;- table(ifnb_merge$stim, ifnb_merge$seurat_clusters)

barplot(tbl, beside = T, main = "Cell numbers in each cluster of each group")
```

![](Session3_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;


---
## Evaluating RPCA using cell types

We can also check the cell types. Using UMAPs we can split and compare across our conditions and cell types. 


```r
DimPlot(ifnb_merge, group.by = "seurat_annotations", split.by = "stim", pt.size = 0.2)
```

![](Session3_files/figure-html/sec3_mergeData_RPCA_eval-1.png)&lt;!-- --&gt;

---
## Evaluating RPCA using cell types

Using heatmaps we can also check how specific each cluster is to each cell type.


```r
library(pheatmap)

tbl &lt;- table(ifnb_merge$seurat_clusters, ifnb_merge$seurat_annotations)
pheatmap(tbl, scale = "column")
```

![](Session3_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---
class: inverse, center, middle

# Merge data with MNN correction

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Merge data with MNN

Mutual Nearest Neighbors (MNN) approach uses paired cells instead of anchor genes to find the difference between batches. 

The MNN correction was published by Marioni et al, Nature (2018). [link](https://www.nature.com/articles/nbt.4091)


---
## Steps for merging data with MNN

1. Convert into SingleCellExperiment
2. Identify features across samples
3. Normalization
4. Identify variables
5. Merge data with MNN correction
6. Build UMAP and clusters
7. Evaluate with UMAP
8. Evaluate composition of samples in each cluster

---
## Preparing to merge data with MNN 

First we have to convert Seurat object to SingleCellExperiment object.


```r
sce_list &lt;- lapply(ifnb_list, function(seu) {
    sce &lt;- as.SingleCellExperiment(seu, assay = "RNA")
    rowData(sce)$SYMBOL &lt;- rownames(sce)
    return(sce)
})


sce_list
```

```
## $CTRL
## class: SingleCellExperiment 
## dim: 14053 6548 
## metadata(0):
## assays(2): counts logcounts
## rownames(14053): AL627309.1 RP11-206L10.2 ... AP001062.7 LRRC3DN
## rowData names(1): SYMBOL
## colnames(6548): AAACATACATTTCC.1 AAACATACCAGAAA.1 ... TTTGCATGCTTCGC.1
##   TTTGCATGGTCCTC.1
## colData names(6): orig.ident nCount_RNA ... seurat_annotations ident
## reducedDimNames(1): PCA
## mainExpName: RNA
## altExpNames(0):
## 
## $STIM
## class: SingleCellExperiment 
## dim: 14053 7451 
## metadata(0):
## assays(2): counts logcounts
## rownames(14053): AL627309.1 RP11-206L10.2 ... AP001062.7 LRRC3DN
## rowData names(1): SYMBOL
## colnames(7451): AAACATACCAAGCT.1 AAACATACCCCTAC.1 ... TTTGCATGCTAAGC.1
##   TTTGCATGGGACGA.1
## colData names(6): orig.ident nCount_RNA ... seurat_annotations ident
## reducedDimNames(1): PCA
## mainExpName: RNA
## altExpNames(0):
```

---
## Preparing to merge data with MNN 

As with RPCA we need to model and identify highly variable genes. For this we will use the scran functions *modelGeneVar()* and *getTopHVGs()*. We simply provide our SingleCellExperiment object.


```r
library(scran)
dec_list &lt;- lapply(sce_list, modelGeneVar)

hvgc_list &lt;- lapply(sce_list, getTopHVGs, prop = 0.1)
```

---
## Preparing to merge data with MNN 

Next we will find the features that are shared between samples. We must first define the shared "universe" of genes between our samples, and subset our variable genes to these. We can then combine the the variance to find variable features in both data sets. 


```r
universe &lt;- intersect(rownames(sce_list$CTRL), rownames(sce_list$STIM))
sce_list &lt;- lapply(sce_list, function(sce, universe) {
    sce &lt;- sce[universe, ]
    return(sce)
}, universe)
dec_list &lt;- lapply(dec_list, function(dec, universe) {
    dec &lt;- dec[universe, ]
    return(dec)
}, universe)

combined_dec &lt;- combineVar(dec_list$CTRL, dec_list$STIM)
chosen_hvgs &lt;- combined_dec$bio &gt; 0
```

---
## Merge data with MNN
We will use the batchelor package to run MNN with the *fastMNN()* function. 
  * d: number of principles evaluated
  * k: number of nearest neighbors to consider
  * subset.row: subset genes. Here, we are using the top variable features

  

```r
library(batchelor)
mnn_res &lt;- fastMNN(CTRL = sce_list$CTRL, STIM = sce_list$STIM, d = 50, k = 20, subset.row = chosen_hvgs)
mnn_res
```

```
## class: SingleCellExperiment 
## dim: 1958 13999 
## metadata(2): merge.info pca.info
## assays(1): reconstructed
## rownames(1958): HES4 ISG15 ... CTD-2521M24.5 AJ006998.2
## rowData names(1): rotation
## colnames(13999): AAACATACATTTCC.1 AAACATACCAGAAA.1 ... TTTGCATGCTAAGC.1
##   TTTGCATGGGACGA.1
## colData names(1): batch
## reducedDimNames(1): corrected
## mainExpName: NULL
## altExpNames(0):
```

---
## Merge data with MNN

The resulting SingleCellExperiment object contains the batch information. We can also retrieve a matrix of our dimension reduction results and corrected log counts with the *reducedDim()* and *assay()* functions. 


```r
table(mnn_res$batch)
```

```
## 
## CTRL STIM 
## 6548 7451
```


```r
reducedDim(mnn_res, "corrected")[1:2, ]
```

```
##                       [,1]         [,2]        [,3]        [,4]        [,5]
## AAACATACATTTCC.1 0.4692084  0.002558405  0.24112457 -0.01932945 -0.02919753
## AAACATACCAGAAA.1 0.4849751 -0.221433858 -0.03194568 -0.04457300  0.02085705
##                           [,6]        [,7]        [,8]         [,9]       [,10]
## AAACATACATTTCC.1  0.0001116506 -0.05219881 -0.01560542  0.018456594 -0.02042355
## AAACATACCAGAAA.1 -0.0208653692  0.02518229 -0.05640069 -0.001590785  0.02042924
##                        [,11]       [,12]        [,13]       [,14]         [,15]
## AAACATACATTTCC.1 0.008021795  0.04396845 -0.005131835 -0.01141103 -0.0002610275
## AAACATACCAGAAA.1 0.006484712 -0.02690261  0.014495238  0.01603657  0.0417677345
##                         [,16]       [,17]        [,18]        [,19]       [,20]
## AAACATACATTTCC.1  0.001044311  0.02583134  0.004660613 -0.003453839 0.007833436
## AAACATACCAGAAA.1 -0.002738321 -0.01539083 -0.028006127  0.010241154 0.016709708
##                         [,21]       [,22]       [,23]        [,24]       [,25]
## AAACATACATTTCC.1 -0.004925768  0.01688819 -0.01693241  0.003615097 0.007882785
## AAACATACCAGAAA.1  0.019963263 -0.02561860  0.01056931 -0.010869553 0.005000099
##                        [,26]        [,27]        [,28]       [,29]        [,30]
## AAACATACATTTCC.1  0.01073247 -0.007515978 -0.006422341 0.004441876 -0.002957034
## AAACATACCAGAAA.1 -0.02215598 -0.000877394  0.003697462 0.014406622  0.003685268
##                        [,31]       [,32]        [,33]        [,34]        [,35]
## AAACATACATTTCC.1 -0.01006521 0.002491115 -0.001875363 -0.008862148 -0.002032289
## AAACATACCAGAAA.1  0.01067559 0.021875399  0.011806194  0.003560579  0.002324063
##                         [,36]        [,37]        [,38]        [,39]
## AAACATACATTTCC.1  0.008468607 -0.007954117 0.0009951654 -0.002792572
## AAACATACCAGAAA.1 -0.002952769 -0.006034000 0.0009532853  0.002280508
##                        [,40]        [,41]         [,42]         [,43]
## AAACATACATTTCC.1 0.002435518  0.015530208 -0.0009633948  0.0026935382
## AAACATACCAGAAA.1 0.010147309 -0.003641573  0.0034695645 -0.0008694543
##                         [,44]        [,45]        [,46]        [,47]
## AAACATACATTTCC.1 0.0002299324 -0.003499860 -0.001978646 -0.009881689
## AAACATACCAGAAA.1 0.0037271479 -0.002181879 -0.001995283 -0.005362725
##                         [,48]        [,49]         [,50]
## AAACATACATTTCC.1  0.004610468 -0.001164966 -0.0095759157
## AAACATACCAGAAA.1 -0.001792342  0.005418251  0.0003605282
```


```r
assay(mnn_res, "reconstructed")[1:2, 1:5]
```

```
## &lt;2 x 5&gt; LowRankMatrix object of type "double":
##       AAACATACATTTCC.1 AAACATACCAGAAA.1 AAACATACCTCGCT.1 AAACATACCTGGTA.1
## HES4      -0.001084752     -0.001208987     -0.001217453      0.001368413
## ISG15     -0.112620920     -0.128283650     -0.111386942     -0.138798526
##       AAACATACGATGAA.1
## HES4      -0.001118792
## ISG15     -0.129904486
```

---
## UMAP of data merged with MNN 

Make UMAP using the scater package.


```r
library(scater)
set.seed(1001)
mnn_res &lt;- runUMAP(mnn_res, dimred = "corrected")
mnn_res$batch &lt;- factor(mnn_res$batch)
plotUMAP(mnn_res, colour_by = "batch")
```

![](Session3_files/figure-html/sec3_dataMerge_MNN_cluster-1.png)&lt;!-- --&gt;


---
## Clustering data merged with MNN 

We will cluster using SNN graph approach from scran as this is comptaible with our SingleCellExperiment object. 


```r
snn.gr &lt;- buildSNNGraph(mnn_res, use.dimred = "corrected")
cluster_mnn &lt;- igraph::cluster_louvain(snn.gr)$membership
table(cluster_mnn)
```

```
## cluster_mnn
##    1    2    3    4    5    6    7    8    9   10   11   12   13   14 
##  656 1455 1139  432  964 1052  769  786  936 2043 1299   44 2368   56
```

---
## Clustering data merged with MNN 

Lets check the UMAP for our clustered results.


```r
mnn_res$cluster &lt;- factor(cluster_mnn)
plotUMAP(mnn_res, colour_by = "cluster")
```

![](Session3_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

---
## Clustering data merged with MNN 

We can also check how many cells from each cluster belong to each group. With this approach you can see that there is a lot more group-specific clusters.


```r
tbl &lt;- table(mnn_res$batch, mnn_res$cluster)
barplot(tbl, beside = T, main = "Cell numbers in each cluster of each group")
```

![](Session3_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

---
## Evaluate with cell types

We must annotate our SingleCellExperiment object with different cell type information. We can then visualize the cell types on our UMAP. 


```r
cellType &lt;- lapply(sce_list, function(x) {
    res &lt;- setNames(as.character(colData(x)$seurat_annotations), colnames(x))
    return(res)
})
cell_type &lt;- c(cellType$CTRL, cellType$STIM)
mnn_res$cell_type &lt;- cell_type[match(rownames(colData(mnn_res)), names(cell_type))]
mnn_res$cell_type &lt;- factor(mnn_res$cell_type)
```


---
## Evaluate with cell types


```r
plotUMAP(mnn_res, colour_by = "cell_type")
```

![](Session3_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

---
## Evaluate with cell types

We can also  use a heatmap to look at the specificity of each cell type to each cluster. Most are cluster-specific.


```r
tbl &lt;- table(mnn_res$cluster, mnn_res$cell_type)
pheatmap(tbl, scale = "column")
```

![](Session3_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---
## MNN vs RPCA

Performance is dependent on experimental context. 

Generally:
* RPCA - More homogeneous   
* MNN - More heterogeneous

---
class: inverse, center, middle

# Merge data with Harmony

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---


## Harmony
- Harmony is an R package for single-cell data integration [liike](https://www.nature.com/articles/s41592-019-0619-0).
- The user manual of Harmony is also available [link](https://portals.broadinstitute.org/harmony/articles/quickstart.html).
- There is also a python implementation of this package. 
- Here, we will demonstrate how to integrate harmony into Seurat regular workflow.

---
## Prepare data for Harmony
We can prepare for Harmony in much the same way as we prepare for the simple Seurat merge: merge, normalize, scale, PCA and UMAP.


```r
seu_obj &lt;- merge(ifnb_list$CTRL, ifnb_list$STIM)
seu_obj &lt;- data_proc(seu_obj)
seu_obj &lt;- ScaleData(seu_obj)
seu_obj &lt;- RunPCA(seu_obj)
seu_obj &lt;- RunUMAP(seu_obj, reduction = "pca", dims = 1:10, reduction.name = "umap")
```

---
## Prepare data for Harmony

As you can see we are back with our completely seperate groups. 


```r
DimPlot(seu_obj)
```

![](Session3_files/figure-html/unnamed-chunk-23-1.png)&lt;!-- --&gt;

---
## Merge data with Harmony

We can use the *RunHarmony()* function to implement the Harmony correction. 


```r
library(harmony)
seu_obj &lt;- RunHarmony(seu_obj, group.by.vars = "stim", assay.use = "RNA")
seu_obj &lt;- RunUMAP(seu_obj, reduction = "harmony", dims = 1:10, reduction.name = "umap_harmony")
DimPlot(seu_obj, reduction = "umap_harmony")
```



---
## An advanced scRNAseq workflow

![overview](./imgs/advancedworkflow.png)


---
class: inverse, center, middle

# Cell type annotation

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Cell type annotation
To annotate the Single-cell data sets, we can evaluate the gene expression pattern of well known cell-type specific marker genes and make a manual annotation, like we did in section II. Here, we will introduce two more strategies to make cell type annotations automatically:
  1. Mapping and annotating query datasets with Seurat using a reference data set.  [link](https://satijalab.org/seurat/articles/integration_mapping.html)
  2. Make annotation with SingleR [link](https://bioconductor.org/packages/release/bioc/html/SingleR.html)

---
## Prepare example datasets

The demo data, *panc8*,  was fetched by using SeuratData(). It contains single-cell RNA-Seq of human pancreatic islet sequenced with different techniques.

The demo data contains
  * CELSeq dataset1 (*GSE81076*), as reference
  * CELSeq dataset2 (*GSE85241*), as reference
  * SMART-Seq2 (*E-MTAB-5061*), as reference
  * Fluidigm C1 (*GSE86469*), as query
  

```r
library(Seurat)
library(SeuratData)
InstallData("panc8")
data("panc8")
head(panc8, 2)
```

```
##        orig.ident nCount_RNA nFeature_RNA   tech replicate assigned_cluster
## D101_5       D101    4615.81         1986 celseq    celseq             &lt;NA&gt;
## D101_7       D101   29001.56         4209 celseq    celseq             &lt;NA&gt;
##        celltype dataset
## D101_5    gamma  celseq
## D101_7   acinar  celseq
```


---
## Prepare example datasets

Split up the datasets by techniques using *SplitObject()*.


```r
seu_list &lt;- SplitObject(panc8, split.by = "tech")
names(seu_list) &lt;- c("celseq1", "celseq2", "smartseq", "fluidigmc1", "indrop")
```

---
## Prepare reference dataset
For this we need a reference dataset and a query dataset. Merge celseq1 and celseq2 data with RPCA to make the reference.


```r
seu_list &lt;- lapply(seu_list, data_proc)
ref_list &lt;- seu_list[c("celseq1", "celseq2")]
feats &lt;- SelectIntegrationFeatures(ref_list)
ref_list &lt;- lapply(ref_list, function(seu, feats) {
    seu &lt;- ScaleData(seu, features = feats, verbose = FALSE)
    seu &lt;- RunPCA(seu, features = feats, verbose = FALSE)
    return(seu)
}, feats)
```

---
## Prepare reference dataset
Merge celseq1 and celseq2 data with RPCA


```r
anchors &lt;- FindIntegrationAnchors(ref_list, anchor.features = feats, reduction = "rpca")
ref_panc &lt;- IntegrateData(anchorset = anchors)
ref_panc &lt;- ScaleData(ref_panc)
ref_panc &lt;- quick_clust(ref_panc)
```

---
## Prepare reference dataset

How does the data look?


```r
DimPlot(ref_panc, group.by = "seurat_clusters", split.by = "tech", pt.size = 0.2,
    label = TRUE)
```

![](Session3_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;


---
## Reference and query datasets


```r
panc_list &lt;- list(ref = ref_panc, query = seu_list$smartseq)
feats &lt;- SelectIntegrationFeatures(panc_list)
panc_list &lt;- lapply(panc_list, function(seu, feats) {
    seu &lt;- ScaleData(seu, features = feats, verbose = FALSE)
    seu &lt;- RunPCA(seu, features = feats, verbose = FALSE)
    return(seu)
}, feats)
```

---
## Predict cell types for query

Identify the anchors between reference and query data sets, using *FindTransferAnchors()*. These are essential to transfer information from our reference to our query. We can then transfer the cell type information. For each cell in query dataset, the score for each given cell type was estimated by the gene expression pattern of anchor genes using the *TransferData()* function. 


```r
anchors &lt;- FindTransferAnchors(reference = panc_list$ref, query = panc_list$query,
    dims = 1:30, reference.reduction = "pca")
pred_res &lt;- TransferData(anchorset = anchors, refdata = panc_list$ref$celltype)
head(pred_res, 2)
```

```
##       predicted.id prediction.score.gamma prediction.score.acinar
## AZ_A2        gamma            0.988556270                       0
## AZ_B9        alpha            0.004147972                       0
##       prediction.score.alpha prediction.score.delta prediction.score.beta
## AZ_A2             0.01144373            0.000000000              0.000000
## AZ_B9             0.85757406            0.009551014              0.128727
##       prediction.score.ductal prediction.score.endothelial
## AZ_A2                       0                            0
## AZ_B9                       0                            0
##       prediction.score.activated_stellate prediction.score.schwann
## AZ_A2                                   0                        0
## AZ_B9                                   0                        0
##       prediction.score.mast prediction.score.macrophage
## AZ_A2                     0                           0
## AZ_B9                     0                           0
##       prediction.score.epsilon prediction.score.quiescent_stellate
## AZ_A2                        0                                   0
## AZ_B9                        0                                   0
##       prediction.score.max
## AZ_A2            0.9885563
## AZ_B9            0.8575741
```

---
## Predict cell types for query
The cell type with highest score was assigned to the given cell. We can visualize this score with a heatmap. 


```r
mat &lt;- as.matrix(pred_res[, -c(1, 15)])
colnames(mat) &lt;- gsub("prediction.score.", "", colnames(mat))
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE)
```

![](Session3_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;

---
## Load cell types into query


```r
pred_cellType &lt;- setNames(pred_res$predicted.id, rownames(pred_res))
panc_list$query[["cellType_predBySeurat"]] &lt;- pred_cellType[match(Cells(panc_list$query),
    names(pred_cellType))]

head(panc_list$query, 2)
```

```
##       orig.ident nCount_RNA nFeature_RNA      tech replicate assigned_cluster
## AZ_A2         AZ     384801         3611 smartseq2 smartseq2             &lt;NA&gt;
## AZ_B9         AZ     654549         4433 smartseq2 smartseq2             &lt;NA&gt;
##       celltype   dataset cellType_predBySeurat
## AZ_A2    gamma smartseq2                 gamma
## AZ_B9    alpha smartseq2                 alpha
```

```r
table(panc_list$query$cellType_predBySeurat)
```

```
## 
##             acinar activated_stellate              alpha               beta 
##                192                 55               1016                320 
##              delta             ductal        endothelial              gamma 
##                125                440                 21                204 
##         macrophage               mast quiescent_stellate            schwann 
##                  7                  7                  5                  2
```

---
## Annotation with SingleR
[SingleR](https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html) is bioconductor package which can be used to predict annotations of a single-cell dataset.

This package uses SingleCellExperiment objects, so we need to convert our Seurat object.


```r
sce_list &lt;- lapply(panc_list, function(seu) {
    sce &lt;- as.SingleCellExperiment(seu, assay = "RNA")
    return(sce)
})
```

---
## Annotation with SingleR

The score is generated comparing the expression levels of a cell in query dataset and the expression pattern of certain group (eg. cell types) in reference dataset. A cell would be assigned as the cell type which has highest score.


```r
library(SingleR)
pred_res &lt;- SingleR(ref = sce_list$ref, test = sce_list$query, labels = sce_list$ref$celltype)
head(pred_res, 2)
```

```
## DataFrame with 2 rows and 4 columns
##                               scores      labels delta.next pruned.labels
##                             &lt;matrix&gt; &lt;character&gt;  &lt;numeric&gt;   &lt;character&gt;
## AZ_A2 0.300904:0.178568:0.436055:...       gamma  0.1394303            NA
## AZ_B9 0.318227:0.227997:0.529730:...       alpha  0.0861217         alpha
```

---
## Annotation with SingleR
By converting to a matrix, we can check the cell type scoring using a heatmap. 


```r
mat &lt;- as.matrix(pred_res$scores)
rownames(mat) &lt;- rownames(pred_res)
pheatmap::pheatmap(mat, scale = "row", show_rownames = FALSE)
```

![](Session3_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;


---
## Import SingleR annotation

Lastly we want to add our annotation back to our query dataset. 


```r
cell_type &lt;- setNames(pred_res$pruned.labels, rownames(pred_res))
panc_list$query$cellType_predBySingleR &lt;- cell_type[match(Cells(panc_list$query),
    names(cell_type))]
head(panc_list$query, 2)
```

```
##       orig.ident nCount_RNA nFeature_RNA      tech replicate assigned_cluster
## AZ_A2         AZ     384801         3611 smartseq2 smartseq2             &lt;NA&gt;
## AZ_B9         AZ     654549         4433 smartseq2 smartseq2             &lt;NA&gt;
##       celltype   dataset cellType_predBySeurat cellType_predBySingleR
## AZ_A2    gamma smartseq2                 gamma                   &lt;NA&gt;
## AZ_B9    alpha smartseq2                 alpha                  alpha
```


---
## Seurat vs SingleR annotation

First we can compare this back to the original annotation. We will look for how many overlap.

Seurat annotation:

```r
table(panc_list$query$cellType_predBySeurat == panc_list$query$celltype)
```

```
## 
## FALSE  TRUE 
##    37  2357
```

SingleR annotation:

```r
table(panc_list$query$cellType_predBySingleR == panc_list$query$celltype)
```

```
## 
## FALSE  TRUE 
##    35  2299
```


---
## Seurat vs SingleR annotation

Next we can compare our two annotations:


```r
table(panc_list$query$cellType_predBySeurat == panc_list$query$cellType_predBySingleR)
```

```
## 
## FALSE  TRUE 
##    39  2295
```

```r
tbl &lt;- table(panc_list$query$cellType_predBySeurat, panc_list$query$cellType_predBySingleR)
pheatmap::pheatmap(tbl, scale = "row")
```

![](Session3_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---
## Seurat vs SingleR annotation

This isn't always the case. This is good demonstration data. 

* Seurat: Wins on speed
* SingleR: More reliable and consistent






    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
